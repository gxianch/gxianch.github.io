<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="前言本地jupyter打开 12(base) xian@guofuchengdeMacBook-Pro ~ % conda activate base(base) xian@guofuchengdeMacBook-Pro ~ % jupyter notebook http:&#x2F;&#x2F;localhost:8888&#x2F;tree&#x2F;PycharmProjects&#x2F;book&#x2F;example-code-2e  第 1">
<meta property="og:type" content="article">
<meta property="og:title" content="流畅的Python（第2版）">
<meta property="og:url" content="http://yoursite.com/2024/03/01/%E6%B5%81%E7%95%85%E7%9A%84Python%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89/index.html">
<meta property="og:site_name" content="郭富城的博客">
<meta property="og:description" content="前言本地jupyter打开 12(base) xian@guofuchengdeMacBook-Pro ~ % conda activate base(base) xian@guofuchengdeMacBook-Pro ~ % jupyter notebook http:&#x2F;&#x2F;localhost:8888&#x2F;tree&#x2F;PycharmProjects&#x2F;book&#x2F;example-code-2e  第 1">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-03-01T06:30:13.000Z">
<meta property="article:modified_time" content="2024-03-04T02:27:22.554Z">
<meta property="article:author" content="郭富城">
<meta property="article:tag" content="✰✰✰✰✰">
<meta property="article:tag" content="※※※">
<meta property="article:tag" content="OReilly">
<meta property="article:tag" content="技术">
<meta property="article:tag" content="python">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2024/03/01/%E6%B5%81%E7%95%85%E7%9A%84Python%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>流畅的Python（第2版） | 郭富城的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">郭富城的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">阅读书籍笔记,不定期更新</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home  //首页"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive   //归档"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags   //标签"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th  //分类"></i>分类</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/03/01/%E6%B5%81%E7%95%85%E7%9A%84Python%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="郭富城">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="郭富城的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          流畅的Python（第2版）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-01 14:30:13" itemprop="dateCreated datePublished" datetime="2024-03-01T14:30:13+08:00">2024-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-04 10:27:22" itemprop="dateModified" datetime="2024-03-04T10:27:22+08:00">2024-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本地jupyter打开</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(base) xian@guofuchengdeMacBook-Pro ~ % conda activate base</span><br><span class="line">(base) xian@guofuchengdeMacBook-Pro ~ % jupyter notebook</span><br></pre></td></tr></table></figure>
<p><a href="http://localhost:8888/tree/PycharmProjects/book/example-code-2e" target="_blank" rel="noopener">http://localhost:8888/tree/PycharmProjects/book/example-code-2e</a></p>
<hr>
<h1 id="第-1-章-Python-数据模型"><a href="#第-1-章-Python-数据模型" class="headerlink" title="第 1 章　Python 数据模型"></a>第 1 章　Python 数据模型</h1><p>不使用 collection.len()，而是使用 len(collection)？这一点表面上看确实奇怪，而且只是众多奇怪行为的冰山一角，不过知道背后的原因之后，你会发现这才真正符合“Python 风格”。一切的一切都埋藏在 Python 数据模型中。我们平常自己创建对象时就要使用这个 API，确保使用最地道的语言功能。<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/16/2/4/10/1%3A48%29">2024/2/19 12:20 PM</a></p>
<hr>
<p>特殊方法的名称前后两端都有双下划线。例如，在 obj[key] 句法背后提供支持的是特殊方法 <strong>getitem</strong>。为了求解 my_collection[key]，Python 解释器要调用 my_collection.<strong>getitem</strong>(key)。<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/16/2/4/14/1%3A81%29">2024/2/19 2:45 PM</a></p>
<hr>
<h2 id="1-2-一摞-Python-风格的纸牌"><a href="#1-2-一摞-Python-风格的纸牌" class="headerlink" title="1.2　一摞 Python 风格的纸牌"></a>1.2　一摞 Python 风格的纸牌</h2><p>self._cards = [Card(rank, suit) for suit in self.suits<br>                                        for rank in self.ranks]</p>
<p><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/16/2/4/38/2/1%3A236%29">2024/2/19 4:13 PM</a></p>
<p>两个for循环可以这样用？</p>
<hr>
<p>虽然 FrenchDeck 类隐式继承 object 类，但是前者的多数功能不是继承而来的，而是源自数据模型和组合模式。通过前面使用 random.choice、reversed 和 sorted 的示例可以看出，实现 <strong>len</strong> 和 <strong>getitem</strong> 两个特殊方法后，FrenchDeck 的行为就像标准的 Python 序列一样，受益于语言核心特性（例如迭代和切片）和标准库。<strong>len</strong> 和 <strong>getitem</strong> 的实现利用组合模式，把所有工作委托给一个 list 对象，即 self.<em>cards。<br>[2024/2/19 4:18 PM](calibre://view-book/_hex</em>-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/16/2/4/88/1%3A0%29)</p>
<hr>
<h2 id="1-3-特殊方法是如何使用的"><a href="#1-3-特殊方法是如何使用的" class="headerlink" title="1.3　特殊方法是如何使用的"></a>1.3　特殊方法是如何使用的</h2><p>我们在编写代码时一般不直接调用特殊方法，除非涉及大量元编程。即便如此，大部分时间也是实现特殊方法，很少显式调用。唯一例外的是 <strong>init</strong> 方法，为自定义的类实现 <strong>init</strong> 方法时经常直接调用它调取超类的初始化方法。<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/16/2/4/102/1%3A0%29">2024/2/19 4:26 PM</a></p>
<hr>
<h3 id="1-3-2-字符串表示形式"><a href="#1-3-2-字符串表示形式" class="headerlink" title="1.3.2　字符串表示形式"></a>1.3.2　字符串表示形式</h3><p>特殊方法 <strong>repr</strong> 供内置函数 repr 调用，获取对象的字符串表示形式。如未定义 <strong>repr</strong> 方法，Vector 实例在 Python 控制台中显示为 &lt;Vector object at 0x10e100070&gt; 形式。<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/16/2/4/152/1%3A0%29">2024/2/19 4:49 PM</a></p>
<hr>
<p>与此形成对照的是，<strong>str</strong> 方法由内置函数 str() 调用，在背后供 print 函数使用，返回对终端用户友好的字符串。</p>
<p>有时，<strong>repr</strong> 方法返回的字符串足够友好，无须再定义 <strong>str</strong> 方法<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/16/2/4/160/1%3A0%29">2024/2/19 4:50 PM</a></p>
<hr>
<p>如果你熟悉的编程语言使用 toString 方法，那么你可能习惯实现 <strong>str</strong> 方法而不是 <strong>repr</strong> 方法。在 Python 中，如果必须二选一的话，请选择 <strong>repr</strong> 方法。<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/16/2/4/164/2/2%3A1%29">2024/2/19 5:03 PM</a></p>
<hr>
<h3 id="1-3-4-容器-API"><a href="#1-3-4-容器-API" class="headerlink" title="1.3.4　容器 API"></a>1.3.4　容器 API</h3><p>图 1-2：基本容器类型的 UML 类图。以斜体显示的方法名称表示抽象方法，必须由具体子类（例如 list 和 dict）实现。其他方法有具体实现，子类可以直接继承<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/16/2/4/184/2/1%3A0%29">2024/2/19 5:03 PM</a></p>
<hr>
<p>Python 不强制要求具体类继承这些抽象基类中的任何一个。只要实现了 <strong>len</strong> 方法，就说明那个类满足 Sized 接口。</p>
<p>Collection 有 3 个十分重要的专用接口：</p>
<p>Sequence 规范 list 和 str 等内置类型的接口；<br>Mapping 被 dict、collections.defaultdict 等实现；<br>Set 是 set 和 frozenset 两个内置类型的接口。<br>只有 Sequence 实现了 Reversible，因为序列要支持以任意顺序排列内容，而 Mapping 和 Set 不需要。<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/16/2/4/190/1%3A0%29">2024/2/19 5:11 PM</a></p>
<hr>
<p>自 Python 3.7 开始，dict 类型正式“有顺序”了，不过只是保留键的插入顺序。你不能随意重新排列 dict 中的键。<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/16/2/4/198/2/2%3A1%29">2024/2/19 5:15 PM</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/660487408" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/660487408</a></p>
<hr>
<h2 id="1-4-特殊方法概述"><a href="#1-4-特殊方法概述" class="headerlink" title="1.4　特殊方法概述"></a>1.4　特殊方法概述</h2><p>表 1-1：特殊方法名称（不含运算符）</p>
<p>分类</p>
<p>方法名称</p>
<p>字符串（字节）表示形式</p>
<p><strong>repr</strong> <strong>str</strong> <strong>format</strong> <strong>bytes</strong> <strong>fspath</strong></p>
<p>转换为数值</p>
<p><strong>bool</strong> <strong>complex</strong> <strong>int</strong> <strong>float</strong> <strong>hash</strong> <strong>index</strong></p>
<p>模拟容器</p>
<p><strong>len</strong> <strong>getitem</strong> <strong>setitem</strong> <strong>delitem</strong> <strong>contains</strong></p>
<p>迭代</p>
<p><strong>iter</strong> <strong>aiter</strong> <strong>next</strong> <strong>anext</strong> <strong>reversed</strong></p>
<p>可调用对象或执行协程</p>
<p><strong>call</strong> <strong>await</strong></p>
<p>上下文管理</p>
<p><strong>enter</strong> <strong>exit</strong> <strong>aexit</strong> <strong>aenter</strong></p>
<p>构造和析构实例</p>
<p><strong>new</strong> <strong>init</strong> <strong>del</strong></p>
<p>属性管理</p>
<p><strong>getattr</strong> <strong>getattribute</strong> <strong>setattr</strong> <strong>delattr</strong> <strong>dir</strong></p>
<p>属性描述符</p>
<p><strong>get</strong> <strong>set</strong> <strong>delete</strong> <strong>set_name</strong></p>
<p>抽象基类</p>
<p><strong>instancecheck</strong> <strong>subclasscheck</strong></p>
<p>类元编程</p>
<p><strong>prepare</strong> <strong>init_subclass</strong> <strong>class_getitem</strong> <strong>mro_entries</strong></p>
<p><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/16/2/4/212/2/1%3A0%29">2024/2/19 5:16 PM</a></p>
<hr>
<p>表 1-2：运算符的符号和背后的特殊方法<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/16/2/4/218/2/1%3A0%29">2024/2/19 5:16 PM</a></p>
<hr>
<p>运算符分类</p>
<p>符号</p>
<p>方法名称</p>
<p>一元数值运算符</p>
<ul>
<li><ul>
<li>abs()</li>
</ul>
</li>
</ul>
<p><strong>neg</strong> <strong>pos</strong> <strong>abs</strong></p>
<p>各种比较运算符</p>
<p>&lt; &lt;= == != &gt; &gt;=</p>
<p><strong>lt</strong> <strong>le</strong> <strong>eq</strong> <strong>ne</strong> <strong>gt</strong> <strong>ge</strong></p>
<p>算术运算符</p>
<ul>
<li><ul>
<li><ul>
<li>/ // % @ divmod() round() ** pow()</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>add</strong> <strong>sub</strong> <strong>mul</strong> <strong>truediv</strong> <strong>floordiv</strong> <strong>mod</strong> <strong>matmul</strong> <strong>divmod</strong> <strong>round</strong> <strong>pow</strong></p>
<p>反向算术运算符</p>
<p>（交换算术运算符的操作数）</p>
<p><strong>radd</strong> <strong>rsub</strong> <strong>rmul</strong> <strong>rtruediv</strong> <strong>rfloordiv</strong> <strong>rmod</strong> <strong>rmatmul</strong> <strong>rdivmod</strong> <strong>rpow</strong></p>
<p>增量赋值算术运算符</p>
<p>+= -= <em>= /= //= %= @= *</em>=</p>
<p><strong>iadd</strong> <strong>isub</strong> <strong>imul</strong> <strong>itruediv</strong> <strong>ifloordiv</strong> <strong>imod</strong> <strong>imatmul</strong> <strong>ipow</strong></p>
<p>按位运算符</p>
<p>&amp; | ^ &lt;&lt; &gt;&gt; ~</p>
<p><strong>and</strong> <strong>or</strong> <strong>xor</strong> <strong>lshift</strong> <strong>rshift</strong> <strong>invert</strong></p>
<p>反向按位运算符</p>
<p>（交换按位运算符的操作数）</p>
<p><strong>rand</strong> <strong>ror</strong> <strong>rxor</strong> <strong>rlshift</strong> <strong>rrshift</strong></p>
<p>增量赋值按位运算符</p>
<p>&amp;= |= ^= &lt;&lt;= &gt;&gt;=</p>
<p><strong>iand</strong> <strong>ior</strong> <strong>ixor</strong> <strong>ilshift</strong> <strong>irshift</strong><br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/16/2/4/220/2/2/2/2/1%3A0%29">2024/2/19 5:17 PM</a></p>
<hr>
<h2 id="1-5-len-为什么不是方法"><a href="#1-5-len-为什么不是方法" class="headerlink" title="1.5　len 为什么不是方法"></a>1.5　len 为什么不是方法</h2><p>把 abs 和 len 看作一元运算符，说不定你更能接受它们表面上看似对函数的调用<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/16/2/4/230/2/2%3A18%29">2024/2/19 5:18 PM</a></p>
<hr>
<h1 id="第-2-章-丰富的序列"><a href="#第-2-章-丰富的序列" class="headerlink" title="第 2 章　丰富的序列"></a>第 2 章　丰富的序列</h1><h2 id="2-2-内置序列类型概览"><a href="#2-2-内置序列类型概览" class="headerlink" title="2.2　内置序列类型概览"></a>2.2　内置序列类型概览</h2><p>Python 标准库用 C 语言实现了丰富的序列类型，列举如下。</p>
<p>容器序列</p>
<p>　　可存放不同类型的项，其中包括嵌套容器。示例：list、tuple 和 collections.deque。</p>
<p>扁平序列</p>
<p>　　可存放一种简单类型的项。示例：str、bytes 和 array.array。</p>
<p><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/30/1%3A0%29">2024/2/19 5:29 PM</a></p>
<hr>
<p>图 2-1：图中展示的是一个元组和一个数组的内存简图，它们各有 3 项。灰色方块（未按比例绘制）表示各个 Python 对象的内存标头。元组中的每一项都是引用，引用的是不同的 Python 对象，对象中还可以存放其他 Python 对象的引用，例如那个包含两个项的列表。相比之下，Python 中的数组整体是一个对象，存放一个 C 语言数组，包含 3 个双精度数</p>
<p><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/44/2/1%3A0%29">2024/2/19 5:27 PM</a></p>
<hr>
<p>因此，扁平序列更加紧凑，但是只能存放原始机器值，例如字节、整数和浮点数。<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/46/1%3A0%29">2024/2/19 5:28 PM</a></p>
<hr>
<p>还可按可变性对序列类型分类。</p>
<p>可变序列</p>
<p>　　例如 list、bytearray、array.array 和 collections.deque。</p>
<p>不可变序列</p>
<p>　　例如 tuple、str 和 bytes。<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/50/1%3A3%29">2024/2/19 5:29 PM</a></p>
<hr>
<p>记住不同序列类型的共同点：有些是可变的，有些是不可变的；有些是容器，有些是扁平的。这有助于你把相关概念延伸到不太熟悉的序列类型上。</p>
<p>list 是最基本的序列类型，是一种可变容器。<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/68/1%3A0%29">2024/2/19 5:30 PM</a></p>
<hr>
<h2 id="2-3-列表推导式和生成器表达式"><a href="#2-3-列表推导式和生成器表达式" class="headerlink" title="2.3　列表推导式和生成器表达式"></a>2.3　列表推导式和生成器表达式</h2><h3 id="2-3-1-列表推导式对可读性的影响"><a href="#2-3-1-列表推导式对可读性的影响" class="headerlink" title="2.3.1　列表推导式对可读性的影响"></a>2.3.1　列表推导式对可读性的影响</h3><p>2.3.1　列表推导式对可读性的影响<br>请你切身体验一下，示例 2-1 和示例 2-2 哪一个更易于理解？</p>
<p>示例 2-1　基于一个字符串构建一个 Unicode 码点列表</p>
<blockquote>
<blockquote>
<blockquote>
<p>symbols = ‘$¢£¥€¤’<br>codes = []<br>for symbol in symbols:<br>…     codes.append(ord(symbol))<br>…<br>codes<br>[36, 162, 163, 165, 8364, 164]<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/82%5Bnav_point_35%5D/1%3A0%29">2024/2/19 5:31 PM</a></p>
</blockquote>
</blockquote>
</blockquote>
<hr>
<p>示例2-2 使用列表推导式基于一个字符串构建一个 Unicode 码点列表</p>
<blockquote>
<blockquote>
<blockquote>
<p>symbols = ‘$¢£¥€¤’<br>codes = [ord(symbol) for symbol in symbols]<br>codes<br>[36, 162, 163, 165, 8364, 164]<br>稍微懂一点 Python 或许就能看懂示例 2-1，但是学会列表推导式后，我觉得示例 2-2 更易于理解，因其意图是明确的。<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/90/2/2/1%3A0%29">2024/2/19 5:31 PM</a></p>
</blockquote>
</blockquote>
</blockquote>
<hr>
<h3 id="2-3-2-列表推导式与-map-和-filter-比较"><a href="#2-3-2-列表推导式与-map-和-filter-比较" class="headerlink" title="2.3.2　列表推导式与 map 和 filter 比较"></a>2.3.2　列表推导式与 map 和 filter 比较</h3><blockquote>
<blockquote>
<blockquote>
<p>symbols = ‘$¢£¥€¤’<br>beyond_ascii = [ord(s) for s in symbols if ord(s) &gt; 127]<br>beyond_ascii<br>[162, 163, 165, 8364, 164]<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/116/2/1%3A0%29">2024/2/19 5:35 PM</a></p>
</blockquote>
</blockquote>
</blockquote>
<hr>
<h3 id="2-3-3-笛卡儿积"><a href="#2-3-3-笛卡儿积" class="headerlink" title="2.3.3　笛卡儿积"></a>2.3.3　笛卡儿积</h3><blockquote>
<blockquote>
<blockquote>
<p>colors = [‘black’, ‘white’]<br>sizes = [‘S’, ‘M’, ‘L’]<br>tshirts = [(color, size) for color in colors for size in sizes]  ❶<br>tshirts<br>[(‘black’, ‘S’), (‘black’, ‘M’), (‘black’, ‘L’), (‘white’, ‘S’),<br>    (‘white’, ‘M’), (‘white’, ‘L’)]<br>for color in colors:  ❷<br>…     for size in sizes:<br>…         print((color, size))<br>…<br>(‘black’, ‘S’)<br>(‘black’, ‘M’)<br>(‘black’, ‘L’)<br>(‘white’, ‘S’)<br>(‘white’, ‘M’)<br>(‘white’, ‘L’)<br>tshirts = [(color, size) for size in sizes      ❸<br>…                          for color in colors]<br>tshirts<br>[(‘black’, ‘S’), (‘white’, ‘S’), (‘black’, ‘M’), (‘white’, ‘M’),<br>    (‘black’, ‘L’), (‘white’, ‘L’)]<br>❶ 先按颜色再按尺寸排列，生成一个元组列表。</p>
</blockquote>
</blockquote>
</blockquote>
<p>❷ 注意，这里两个循环的嵌套方式与列表推导式中 for 子句的先后顺序一样。</p>
<p>❸ 如果想先按尺寸再按颜色排列，则只需要调整 for 子句的顺序。我在这里插入了一个换行符，这样排列顺序就更明显了。</p>
<p><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/134/2/1%3A0%29">2024/2/19 5:36 PM</a></p>
<hr>
<h3 id="2-3-4-生成器表达式"><a href="#2-3-4-生成器表达式" class="headerlink" title="2.3.4　生成器表达式"></a>2.3.4　生成器表达式</h3><p>2.3.4　生成器表达式<br>虽然列表推导式也可以生成元组、数组或其他类型的序列，但是生成器表达式占用的内存更少，因为生成器表达式使用迭代器协议逐个产出项，而不是构建整个列表提供给其他构造函数。</p>
<p><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/148%5Bnav_point_38%5D/1%3A0%29">2024/2/19 5:38 PM</a></p>
<hr>
<p>生成器表达式的句法跟列表推导式几乎一样，只不过把方括号换成圆括号而已。</p>
<p>示例 2-5 使用生成器表达式构建一个元组和一个数组。</p>
<p>示例 2-5　使用生成器表达式构建一个元组和一个数组</p>
<blockquote>
<blockquote>
<blockquote>
<p>symbols = ‘$¢£¥€¤’<br>tuple(ord(symbol) for symbol in symbols)  ❶<br>(36, 162, 163, 165, 8364, 164)<br>import array<br>array.array(‘I’, (ord(symbol) for symbol in symbols))  ❷<br>array(‘I’, [36, 162, 163, 165, 8364, 164])<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/152/1%3A0%29">2024/2/19 5:38 PM</a></p>
</blockquote>
</blockquote>
</blockquote>
<hr>
<h2 id="2-4-元组不仅仅是不可变列表"><a href="#2-4-元组不仅仅是不可变列表" class="headerlink" title="2.4　元组不仅仅是不可变列表"></a>2.4　元组不仅仅是不可变列表</h2><p>2.4　元组不仅仅是不可变列表<br>有些 Python 入门教程把元组称为“不可变列表”，然而这没有完全概括元组的特点。元组有两个作用，除了可以作为不可变列表使用之外，还可用作没有字段名称的记录。<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/176%5Bnav_point_39%5D/1%3A0%29">2024/2/21 4:21 PM</a></p>
<p>元组是列表的延伸，列表内部是单个元素，元祖内部元素可以是多个</p>
<hr>
<h3 id="2-4-1-用作记录"><a href="#2-4-1-用作记录" class="headerlink" title="2.4.1　用作记录"></a>2.4.1　用作记录</h3><p>示例 2-7　把元组当作记录使用</p>
<blockquote>
<blockquote>
<blockquote>
<p>lax_coordinates = (33.9425, -118.408056)  ❶<br>city, year, pop, chg, area = (‘Tokyo’, 2003, 32_450, 0.66, 8014)  ❷<br>traveler_ids = [(‘USA’, ‘31195855’), (‘BRA’, ‘CE342567’),  ❸<br>…     (‘ESP’, ‘XDA205856’)]<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/188/2/2/1%3A0%29">2024/2/20 5:08 PM</a></p>
</blockquote>
</blockquote>
</blockquote>
<hr>
<p>一个元组列表，元组的形式为 (country_code, passport_number)。<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/196/1%3A2%29">2024/2/20 5:08 PM</a></p>
<hr>
<p>仅使用一个语句就把 (‘Tokyo’, 2003, 32_450, 0.66, 8014) 赋值给了 city, year, pop, chg, area。<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/208/1%3A66%29">2024/2/20 5:09 PM</a></p>
<hr>
<h3 id="2-4-2-用作不可变列表"><a href="#2-4-2-用作不可变列表" class="headerlink" title="2.4.2　用作不可变列表"></a>2.4.2　用作不可变列表</h3><p>2.4.2　用作不可变列表<br>Python 解释器和标准库经常把元组当作不可变列表使用，你也可以。这么做主要有两个好处。</p>
<p>意图清晰</p>
<p>　　只要在源码中见到元组，你就知道它的长度永不可变。</p>
<p><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/214%5Bnav_point_41%5D/1%3A0%29">2024/2/20 5:09 PM</a></p>
<hr>
<p>性能优越</p>
<p>　　长度相同的元组和列表，元组占用的内存更少，而且 Python 可对元组做些优化。</p>
<p><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/222/2/1%3A0%29">2024/2/20 5:09 PM</a></p>
<hr>
<p>元组依然广泛用作不可变列表。Stack Overflow 网站中有一个问题，题为“Are tuples more efficient than lists in Python?”<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/244/1%3A5%29">2024/2/20 5:12 PM</a></p>
<hr>
<p>tuple 实例长度固定，分配的内存空间正好够用。而 list 实例的内存空间要富余一些，时刻准备追加元素。</p>
<p><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/246/6/2/1%3A0%29">2024/2/20 5:12 PM</a></p>
<hr>
<h3 id="2-4-3-列表和元组方法的比较"><a href="#2-4-3-列表和元组方法的比较" class="headerlink" title="2.4.3　列表和元组方法的比较"></a>2.4.3　列表和元组方法的比较</h3><p>把元组当作列表的不可变变体使用时，有必要了解二者 API 之间的异同。从表 2-1 可以看出，元组支持所有不涉及增删项的列表方法，而且元组没有 <strong>reversed</strong> 方法。<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/250/1%3A0%29">2024/2/21 3:15 PM</a></p>
<hr>
<p>表 2-1：列表和元组的方法及属性<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/252/2/1%3A0%29">2024/2/21 3:15 PM</a></p>
<hr>
<h2 id="2-5-序列和可迭代对象拆包"><a href="#2-5-序列和可迭代对象拆包" class="headerlink" title="2.5　序列和可迭代对象拆包"></a>2.5　序列和可迭代对象拆包</h2><p>最明显的拆包形式是并行赋值（parallel assignment），即把可迭代对象中的项赋值给变量元组，如以下示例所示。</p>
<blockquote>
<blockquote>
<blockquote>
<p>lax_coordinates = (33.9425, -118.408056)<br>latitude, longitude = lax_coordinates  # 拆包<br>latitude<br>33.9425<br>longitude<br>-118.408056<br>利用拆包还可以轻松对调两个变量的值，省掉中间的临时变量。</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>b, a = a, b<br>调用函数时在参数前面加上一个 *，利用的也是拆包。</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>divmod(20, 8)<br>(2, 4)<br>t = (20, 8)<br>divmod(<em>t)<br>(2, 4)<br>quotient, remainder = divmod(</em>t)<br>quotient, remainder<br>(2, 4)<br>上述代码还展示了拆包的另一个用途：为函数返回多个值提供一种便于调用方使用的方式。再举一个例子：os.path.split() 函数根据传入的文件系统路径构建元组 (path, last_part)。</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>import os<br><em>, filename = os.path.split(‘/home/luciano/.ssh/id_rsa.pub’)<br>filename<br>‘id_rsa.pub’<br>如果只需要拆包得到的部分项，那么还可以使用 2.5.1 节介绍的 * 句法。<br>[2024/2/21 3:18 PM](calibre://view-book/_hex</em>-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/266/1%3A0%29)</p>
</blockquote>
</blockquote>
</blockquote>
<hr>
<h3 id="2-5-1-使用-获取余下的项"><a href="#2-5-1-使用-获取余下的项" class="headerlink" title="2.5.1　使用 * 获取余下的项"></a>2.5.1　使用 * 获取余下的项</h3><p>2.5.1　使用 * 获取余下的项<br>定义函数时可以使用 *args 捕获余下的任意数量的参数，这是 Python 的一个经典特性。<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/284%5Bnav_point_44%5D/1%3A0%29">2024/2/21 3:19 PM</a></p>
<hr>
<p>Python 3 把这一思想延伸到了并行赋值上。</p>
<blockquote>
<blockquote>
<blockquote>
<p>a, b, *rest = range(5)<br>a, b, rest<br>(0, 1, [2, 3, 4])<br>a, b, *rest = range(3)<br>a, b, rest<br>(0, 1, [2])<br>a, b, *rest = range(2)<br>a, b, rest<br>(0, 1, [])<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/288/1%3A0%29">2024/2/21 3:19 PM</a></p>
</blockquote>
</blockquote>
</blockquote>
<hr>
<h3 id="2-5-3-嵌套拆包"><a href="#2-5-3-嵌套拆包" class="headerlink" title="2.5.3　嵌套拆包"></a>2.5.3　嵌套拆包</h3><p>2.5.3　嵌套拆包<br>拆包的对象可以嵌套，例如 (a, b, (c, d))。如果值的嵌套结构是相同的，则 Python 能正确处理。示例 2-8 演示了嵌套拆包的具体用法。</p>
<p>示例 2-8　拆包嵌套元组，获取经度</p>
<p>metro_areas = [<br>    (‘Tokyo’, ‘JP’, 36.933, (35.689722, 139.691667)),  ❶<br>    (‘Delhi NCR’, ‘IN’, 21.935, (28.613889, 77.208889)),<br>    (‘Mexico City’, ‘MX’, 20.142, (19.433333, -99.133333)),<br>    (‘New York-Newark’, ‘US’, 20.104, (40.808611, -74.020386)),<br>    (‘São Paulo’, ‘BR’, 19.649, (-23.547778, -46.635833)),<br>]</p>
<p><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/312%5Bnav_point_46%5D/1%3A0%29">2024/2/21 3:21 PM</a></p>
<hr>
<p> for name, <em>, _, (lat, lon) in metro_areas:  ❷<br>[2024/2/21 3:21 PM](calibre://view-book/_hex</em>-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/318/2/1%3A390%29)</p>
<hr>
<h2 id="2-7-切片"><a href="#2-7-切片" class="headerlink" title="2.7　切片"></a>2.7　切片</h2><p>2.7　切片<br>在 Python 中，列表、元组、字符串等所有序列类型都支持切片操作。切片比多数人认为的要强大很多。<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/476%5Bnav_point_49%5D/1%3A0%29">2024/2/21 3:30 PM</a></p>
<hr>
<h3 id="2-7-1-为什么切片和区间排除最后一项"><a href="#2-7-1-为什么切片和区间排除最后一项" class="headerlink" title="2.7.1　为什么切片和区间排除最后一项"></a>2.7.1　为什么切片和区间排除最后一项</h3><p>方便在索引 x 处把一个序列拆分成两部分而不产生重叠，直接使用 my_list[:x] 和 my_list[x:] 即可。例如：</p>
<blockquote>
<blockquote>
<blockquote>
<p>l = [10, 20, 30, 40, 50, 60]<br>l[:2]  # 在索引位2处拆分<br>[10, 20]<br>l[2:]<br>[30, 40, 50, 60]<br>l[:3]  # 在索引位3处拆分<br>[10, 20, 30]<br>l[3:]<br>[40, 50, 60]<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/486/6/2/1%3A0%29">2024/2/21 3:31 PM</a></p>
</blockquote>
</blockquote>
</blockquote>
<hr>
<h3 id="2-7-4-为切片赋值"><a href="#2-7-4-为切片赋值" class="headerlink" title="2.7.4　为切片赋值"></a>2.7.4　为切片赋值</h3><p>2.7.4　为切片赋值<br>在赋值语句的左侧使用切片表示法，或者作为 del 语句的目标，可以就地移植、切除或以其他方式修改可变序列。下面举几个例子演示这种表示法的强大功能。</p>
<blockquote>
<blockquote>
<blockquote>
<p>l = list(range(10))<br>l<br>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<br>l[2:5] = [20, 30]<br>l<br>[0, 1, 20, 30, 5, 6, 7, 8, 9]<br>del l[5:7]<br>l<br>[0, 1, 20, 30, 5, 8, 9]<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/530%5Bnav_point_53%5D/1%3A0%29">2024/2/21 3:33 PM</a></p>
</blockquote>
</blockquote>
</blockquote>
<hr>
<h2 id="2-8-使用-和-处理序列"><a href="#2-8-使用-和-处理序列" class="headerlink" title="2.8　使用 + 和 * 处理序列"></a>2.8　使用 + 和 * 处理序列</h2><p>2.8　使用 + 和 * 处理序列<br>Python 程序员预期序列支持 + 和 *。通常，+ 的两个运算对象必须是同一种序列，而且都不可修改，拼接的结果是一个同类型的新序列。</p>
<p>如果想多次拼接同一个序列，可以乘以一个整数。同样，结果是一个新创建的序列。</p>
<blockquote>
<blockquote>
<blockquote>
<p>l = [1, 2, 3]<br>l * 5<br>[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]<br>5 * ‘abcd’<br>‘abcdabcdabcdabcdabcd’</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>和 * 始终创建一个新对象，绝不更改操作数。<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/540%5Bnav_point_54%5D/1%3A0%29">2024/2/21 3:34 PM</a></li>
</ul>
<hr>
<h2 id="2-9-list-sort-与内置函数-sorted"><a href="#2-9-list-sort-与内置函数-sorted" class="headerlink" title="2.9　list.sort 与内置函数 sorted"></a>2.9　list.sort 与内置函数 sorted</h2><p>2.9　list.sort 与内置函数 sorted<br>list.sort 方法就地排序列表，即不创建副本。返回值为 None，目的就是提醒我们，它更改了接收者，11 没有创建新列表。这是 Python API 的一个重要约定：就地更改对象的函数或方法应该返回 None，让调用方清楚地知道接收者已被更改，没有创建新对象。<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/680%5Bnav_point_58%5D/1%3A0%29">2024/2/21 3:37 PM</a></p>
<hr>
<p>与之相反，内置函数 sorted 返回创建的新列表。<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/688/1%3A0%29">2024/2/21 3:38 PM</a></p>
<hr>
<h2 id="2-10-当列表不适用时"><a href="#2-10-当列表不适用时" class="headerlink" title="2.10　当列表不适用时"></a>2.10　当列表不适用时</h2><p>2.10　当列表不适用时<br>list 类型简单灵活，不过，针对具体的需求，或许还有更好的选择。例如，使用数组处理上百万个浮点值可以节省大量内存。另外，如果经常需要在列表的两端添加和删除项，使用 deque（double-ended queue，双端队列）更合适，这是一种更高效的 FIFO14 数据结构。<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/732%5Bnav_point_59%5D/1%3A0%29">2024/2/21 3:39 PM</a></p>
<hr>
<p>如果你在代码中经常检查容器中是否存在某一项（例如 item in my_collection），应考虑使用 set 类型存储 my_collection，尤其是项数较多的情况。Python 对 set 成员检查做了优化，速度更快。set 也是可迭代对象，但不是序列，因为 set 中的项是无序的<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/738/2/2%3A1%29">2024/2/21 3:40 PM</a></p>
<hr>
<h3 id="2-10-1-数组"><a href="#2-10-1-数组" class="headerlink" title="2.10.1　数组"></a>2.10.1　数组</h3><p>2.10.1　数组<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/742%5Bnav_point_60%5D/1%3A0%29">2024/2/21 3:54 PM</a></p>
<hr>
<p>如果一个列表只包含数值，那么使用 array.array 会更高效。数组支持所有可变序列操作（包括 .pop、.insert 和 .extend），此外还有快速加载项和保存项的方法，例如 .frombytes 和 .tofile。<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/744/1%3A0%29">2024/2/21 3:54 PM</a></p>
<hr>
<p>表 2-3：list 和 array 的方法及属性<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/776/2/1%3A0%29">2024/2/21 3:56 PM</a></p>
<hr>
<h3 id="2-10-3-NumPy"><a href="#2-10-3-NumPy" class="headerlink" title="2.10.3　NumPy"></a>2.10.3　NumPy</h3><p>示例 2-22 简单演示 NumPy 的用法，对二维数组做了些基本操作。</p>
<p>示例 2-22　numpy.ndarray 中行和列的基本操作</p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np ❶<br>a = np.arange(12)  ❷<br>a<br>array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])<br>type(a)<br>&lt;class ‘numpy.ndarray’&gt;<br>a.shape  ❸<br>(12,)<br>a.shape = 3, 4  ❹<br>a<br>array([[ 0,  1,  2,  3],<br>       [ 4,  5,  6,  7],<br>       [ 8,  9, 10, 11]])<br>a[2]  ❺<br>array([ 8,  9, 10, 11])<br>a[2, 1]  ❻<br>9<br>a[:, 1]  ❼<br>array([1, 5, 9])<br>a.transpose()  ❽<br>array([[ 0,  4,  8],<br>       [ 1,  5,  9],<br>       [ 2,  6, 10],<br>       [ 3,  7, 11]])<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/842/1%3A0%29">2024/2/21 3:59 PM</a></p>
</blockquote>
</blockquote>
</blockquote>
<hr>
<p>NumPy 和 SciPy 这两个库的功能异常强大，为很多优秀的工具提供了坚实的基础，例如 Pandas 和 scikit-learn。Pandas 实现的高效数组类型可以保存非数值数据，此外还支持导入和导出多种格式，包括 .csv、.xls、SQL 转储、HDF5 等。scikit-learn 是目前最广泛使用的机器学习工具集。<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/886/1%3A0%29">2024/2/21 4:00 PM</a></p>
<hr>
<h2 id="2-11-本章小结"><a href="#2-11-本章小结" class="headerlink" title="2.11　本章小结"></a>2.11　本章小结</h2><p>元组在 Python 中扮演两个角色，一是不具名字段记录，二是不可变列表。把元组当作不可变列表使用时请记住，仅当元组中的所有项也都是不可变对象时，才能保证元组值是固定的。在元组上调用 hash(t) 函数可以快速判断元组的值是否固定。如果 t 包含可变的项，则 hash(t) 抛出 TypeError。</p>
<p>把元组当作记录使用时，元组拆包是提取元组字段最安全、可读性最高的方法。除了元组之外，* 在许多上下文中还适用于列表和可迭代对象。<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/954/1%3A0%29">2024/2/21 4:02 PM</a></p>
<hr>
<p>序列切片是最受欢迎的 Python 句法特性之一，其功能比许多人所想的还要强大。用户定义的序列甚至可以支持 NumPy 那种多维切片和省略号（…）表示法。通过切片赋值修改可变序列是极具表现力的操作。</p>
<p><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/958/1%3A0%29">2024/2/21 4:02 PM</a></p>
<hr>
<h2 id="2-12-延伸阅读"><a href="#2-12-延伸阅读" class="headerlink" title="2.12　延伸阅读"></a>2.12　延伸阅读</h2><p>与列表不同，元组通常包含不同类型的项。这也符合常理：如果元组中的每一项都是一个字段，那么每个字段就可以具有不同的类型。<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/18/2/4/992/32/1%3A0%29">2024/2/21 4:07 PM</a></p>
<hr>
<h1 id="第-3-章-字典和集合"><a href="#第-3-章-字典和集合" class="headerlink" title="第 3 章　字典和集合"></a>第 3 章　字典和集合</h1><h2 id="3-1-本章新增内容"><a href="#3-1-本章新增内容" class="headerlink" title="3.1　本章新增内容"></a>3.1　本章新增内容</h2><p>dict 和 set 的底层实现仍然依赖于哈希表，不过 dict 的代码有两项重要的优化，节省了内存，还能保留键的插入顺序。<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/20/2/4/22/2/1%3A0%29">2024/2/21 4:13 PM</a></p>
<hr>
<h2 id="3-2-字典的现代句法"><a href="#3-2-字典的现代句法" class="headerlink" title="3.2　字典的现代句法"></a>3.2　字典的现代句法</h2><h3 id="3-2-1-字典推导式"><a href="#3-2-1-字典推导式" class="headerlink" title="3.2.1　字典推导式"></a>3.2.1　字典推导式</h3><p>3.2.1　字典推导式<br>自 Python 2.7 开始，列表推导式和生成器表达式经过改造，以适用于字典推导式（以及后文要讲的集合推导式）。字典推导式从任何可迭代对象中获取键值对，构建 dict 实例。示例 3-1 使用字典推导式根据同一个元组列表构建两个字典。</p>
<p>示例 3-1　字典推导式示例</p>
<blockquote>
<blockquote>
<blockquote>
<p>dial_codes = [                                                  ❶<br>…     (880, ‘Bangladesh’),<br>…     (55,  ‘Brazil’),<br>…     (86,  ‘China’),<br>…     (91,  ‘India’),<br>…     (62,  ‘Indonesia’),<br>…     (81,  ‘Japan’),<br>…     (234, ‘Nigeria’),<br>…     (92,  ‘Pakistan’),<br>…     (7,   ‘Russia’),<br>…     (1,   ‘United States’),<br>… ]<br>country_dial = {country: code for code, country in dial_codes}  ❷<br>country_dial<br>{‘Bangladesh’: 880, ‘Brazil’: 55, ‘China’: 86, ‘India’: 91, ‘Indonesia’: 62,<br>‘Japan’: 81, ‘Nigeria’: 234, ‘Pakistan’: 92, ‘Russia’: 7, ‘United States’: 1}<br>{code: country.upper()                                          ❸<br>…     for country, code in sorted(country_dial.items())<br>…     if code &lt; 70}<br>{55: ‘BRAZIL’, 62: ‘INDONESIA’, 7: ‘RUSSIA’, 1: ‘UNITED STATES’}<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/20/2/4/28%5Bnav_point_69%5D/1%3A0%29">2024/2/21 4:24 PM</a></p>
</blockquote>
</blockquote>
</blockquote>
<hr>
<h2 id="3-8-字典视图"><a href="#3-8-字典视图" class="headerlink" title="3.8　字典视图"></a>3.8　字典视图</h2><p>dict 的实例方法 .keys()、.values() 和 .items() 分别返回 dict_keys、dict_values 和 dict_items 类的实例。这些字典视图是 dict 内部实现使用的数据结构的只读投影。<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/20/2/4/434/2/1%3A0%29">2024/2/21 4:35 PM</a></p>
<hr>
<h2 id="3-10-集合论"><a href="#3-10-集合论" class="headerlink" title="3.10　集合论"></a>3.10　集合论</h2><p>本书使用“集合”一词指代 set 和 frozenset。<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/20/2/4/482/2/2%3A1%29">2024/2/21 4:37 PM</a></p>
<hr>
<p>集合是一组唯一的对象。集合的基本作用是去除重复项。</p>
<blockquote>
<blockquote>
<blockquote>
<p>l = [‘spam’, ‘spam’, ‘eggs’, ‘spam’, ‘bacon’, ‘eggs’]<br>set(l)<br>{‘eggs’, ‘spam’, ‘bacon’}<br>list(set(l))<br>[‘eggs’, ‘spam’, ‘bacon’]<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/20/2/4/484/1%3A0%29">2024/2/21 4:37 PM</a></p>
</blockquote>
</blockquote>
</blockquote>
<hr>
<p>如果想去除重复项，同时保留每一项首次出现位置的顺序，那么现在使用普通的 dict 即可，如下所示。</p>
<blockquote>
<blockquote>
<blockquote>
<p>dict.fromkeys(l).keys()<br>dict_keys([‘spam’, ‘eggs’, ‘bacon’])<br>list(dict.fromkeys(l).keys())<br>[‘spam’, ‘eggs’, ‘bacon’]<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/20/2/4/488/2/2%3A1%29">2024/2/21 4:38 PM</a></p>
</blockquote>
</blockquote>
</blockquote>
<hr>
<h1 id="第-5-章-数据类构建器"><a href="#第-5-章-数据类构建器" class="headerlink" title="第 5 章　数据类构建器"></a>第 5 章　数据类构建器</h1><p>Python 提供了几种构建简单类的方式，这些类只是字段的容器，几乎没有额外功能。这种模式称为“数据类”（data class），dataclasses 包就支持该模式。<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/24/2/4/8/1%3A0%29">2024/2/22 4:51 PM</a></p>
<hr>
<h2 id="5-2-数据类构建器概述"><a href="#5-2-数据类构建器概述" class="headerlink" title="5.2　数据类构建器概述"></a>5.2　数据类构建器概述</h2><p>下面使用 namedtuple 构建 Coordinate 类。namedtuple 是一个工厂方法，使用指定的名称和字段构建 tuple 的子类。</p>
<blockquote>
<blockquote>
<blockquote>
<p>from collections import namedtuple<br>Coordinate = namedtuple(‘Coordinate’, ‘lat lon’)<br>issubclass(Coordinate, tuple)<br>True<br>moscow = Coordinate(55.756, 37.617)<br>moscow<br>Coordinate(lat=55.756, lon=37.617)  ❶<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/24/2/4/54/1%3A0%29">2024/2/22 4:53 PM</a></p>
</blockquote>
</blockquote>
</blockquote>
<hr>
<h1 id="第-6-章-对象引用、可变性和垃圾回收"><a href="#第-6-章-对象引用、可变性和垃圾回收" class="headerlink" title="第 6 章　对象引用、可变性和垃圾回收"></a>第 6 章　对象引用、可变性和垃圾回收</h1><h2 id="6-6-del-和垃圾回收"><a href="#6-6-del-和垃圾回收" class="headerlink" title="6.6　del 和垃圾回收"></a>6.6　del 和垃圾回收</h2><p>其次，del 语句删除引用，而不是对象。<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/26/2/4/374/1%3A0%29">2024/2/23 9:41 AM</a></p>
<hr>
<h1 id="第-7-章-函数是一等对象"><a href="#第-7-章-函数是一等对象" class="headerlink" title="第 7 章　函数是一等对象"></a>第 7 章　函数是一等对象</h1><h2 id="7-3-高阶函数"><a href="#7-3-高阶函数" class="headerlink" title="7.3　高阶函数"></a>7.3　高阶函数</h2><h3 id="map、filter-和-reduce-的现代替代品"><a href="#map、filter-和-reduce-的现代替代品" class="headerlink" title="map、filter 和 reduce 的现代替代品"></a>map、filter 和 reduce 的现代替代品</h3><p>sum 和 reduce 的整体运作方式是一样的，即把某个操作连续应用到序列中的项上，累计前一个结果，把一系列值归约成一个值。<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/30/2/4/106/2/4/1%3A0%29">2024/2/23 10:24 AM</a></p>
<hr>
<h2 id="7-5-9-种可调用对象"><a href="#7-5-9-种可调用对象" class="headerlink" title="7.5　9 种可调用对象"></a>7.5　9 种可调用对象</h2><p>生成器函数</p>
<p>　　主体中有 yield 关键字的函数或方法。调用生成器函数返回一个生成器对象。</p>
<p>原生协程函数</p>
<p>　　使用 async def 定义的函数或方法。调用原生协程函数返回一个协程对象。Python 3.5 新增。</p>
<p>异步生成器函数</p>
<p>　　使用 async def 定义，而且主体中有 yield 关键字的函数或方法。调用异步生成器函数返回一个异步生成器，供 async for 使用。Python 3.6 新增。</p>
<p>与其他可调用对象不同，生成器、原生协程和异步生成器函数的返回值不是应用程序数据，而是需要进一步处理的对象，要么产出应用程序数据，要么执行某种操作。生成器函数会返回迭代器（详见第 17 章）。原生协程函数和异步生成器函数返回的对象只能由异步编程框架（例如 asyncio）处理（详见第 21 章）。</p>
<p><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/30/2/4/170/2/1%3A0%29">2024/2/23 10:28 AM</a></p>
<hr>
<h2 id="7-10-延伸阅读"><a href="#7-10-延伸阅读" class="headerlink" title="7.10　延伸阅读"></a>7.10　延伸阅读</h2><p>函数有名称，栈跟踪更易于阅读。匿名函数是一种便利的简洁方式，人们乐于使用它们，但是有时会忘乎所以，尤其是在鼓励深层嵌套匿名函数的语言和环境中，例如 Node.js 之上的 JavaScript。匿名函数嵌套的层级太深，不利于调试和处理错误。<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/30/2/4/414/32/1%3A8%29">2024/3/1 9:27 AM</a></p>
<hr>
<h1 id="第-10-章-使用一等函数实现设计模式"><a href="#第-10-章-使用一等函数实现设计模式" class="headerlink" title="第 10 章　使用一等函数实现设计模式"></a>第 10 章　使用一等函数实现设计模式</h1><h2 id="10-2-案例分析：重构策略模式"><a href="#10-2-案例分析：重构策略模式" class="headerlink" title="10.2　案例分析：重构策略模式"></a>10.2　案例分析：重构策略模式</h2><h3 id="10-2-1-经典的策略模式"><a href="#10-2-1-经典的策略模式" class="headerlink" title="10.2.1　经典的策略模式"></a>10.2.1　经典的策略模式</h3><p>class Promotion(ABC):  # 策略：抽象基类<br>    @abstractmethod<br>    def discount(self, order: Order) -&gt; Decimal:<br>        “””返回折扣金额（正值）”””</p>
<p>class FidelityPromo(Promotion):  # 第一个具体策略<br>    “””为积分为1000或以上的顾客提供5%折扣”””</p>
<pre><code>def discount(self, order: Order) -&gt; Decimal:
    rate = Decimal(&apos;0.05&apos;)
    if order.customer.fidelity &gt;= 1000:
        return order.total() * rate
    return Decimal(0)</code></pre><p><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/36/2/4/68/2/1%3A930%29">2024/3/1 9:45 AM</a></p>
<hr>
<h1 id="第-11-章-符合-Python-风格的对象"><a href="#第-11-章-符合-Python-风格的对象" class="headerlink" title="第 11 章　符合 Python 风格的对象"></a>第 11 章　符合 Python 风格的对象</h1><h2 id="11-5-classmethod-与-staticmethod"><a href="#11-5-classmethod-与-staticmethod" class="headerlink" title="11.5　classmethod 与 staticmethod"></a>11.5　classmethod 与 staticmethod</h2><p>classmethod 装饰器非常有用，但是我从未见过不得不使用 staticmethod 的情况。有些函数即使不直接处理类，也与类联系紧密，因此你会想把函数与类放在一起定义。对于这种情况，在类的前面或后面定义函数，保持二者在同一个模块中基本上就可以了。5</p>
<p><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/40/2/4/152/2/4/1%3A0%29">2024/3/1 2:55 PM</a></p>
<hr>
<h1 id="第-17-章-迭代器、生成器和经典协程"><a href="#第-17-章-迭代器、生成器和经典协程" class="headerlink" title="第 17 章　迭代器、生成器和经典协程"></a>第 17 章　迭代器、生成器和经典协程</h1><h2 id="17-5-为-Sentence-类实现-iter-方法"><a href="#17-5-为-Sentence-类实现-iter-方法" class="headerlink" title="17.5　为 Sentence 类实现 iter 方法"></a>17.5　为 Sentence 类实现 <strong>iter</strong> 方法</h2><h3 id="17-5-4-生成器的工作原理"><a href="#17-5-4-生成器的工作原理" class="headerlink" title="17.5.4　生成器的工作原理"></a>17.5.4　生成器的工作原理</h3><p>17.5.4　生成器的工作原理<br>只要 Python 函数的主体中有 yield 关键字，该函数就是生成器函数。调用生成器函数，返回一个生成器对象。也就是说，生成器函数是生成器工厂。<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/54/2/4/286%5Bnav_point_364%5D/1%3A0%29">2024/3/1 3:27 PM</a></p>
<hr>
<h2 id="17-11-yield-from：从子生成器中产出"><a href="#17-11-yield-from：从子生成器中产出" class="headerlink" title="17.11　yield from：从子生成器中产出"></a>17.11　yield from：从子生成器中产出</h2><p>17.11　yield from：从子生成器中产出<br>Python 3.3 新增的 yield from 表达式句法可把一个生成器的工作委托给一个子生成器。</p>
<p>引入 yield from 之前，如果一个生成器根据另一个生成器生成的值产出值，则需要使用 for 循环。</p>
<blockquote>
<blockquote>
<blockquote>
<p>def sub_gen():<br>…     yield 1.1<br>…     yield 1.2<br>…<br>def gen():<br>…     yield 1<br>…     for i in sub_gen():<br>…         yield i<br>…     yield 2<br>…<br>for x in gen():<br>…     print(x)<br>…<br>1<br>1.1<br>1.2<br>2<br>使用 yield from 可以达到相同的效果，如示例 17-25 所示。</p>
</blockquote>
</blockquote>
</blockquote>
<p>示例 17-25　测试驱动 yield from</p>
<blockquote>
<blockquote>
<blockquote>
<p>def sub_gen():<br>…     yield 1.1<br>…     yield 1.2<br>…<br>def gen():<br>…     yield 1<br>…     yield from sub_gen()<br>…     yield 2<br>…<br>for x in gen():<br>…     print(x)<br>…<br>1<br>1.1<br>1.2<br>2<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/54/2/4/718%5Bnav_point_373%5D/1%3A0%29">2024/3/1 4:05 PM</a></p>
</blockquote>
</blockquote>
</blockquote>
<hr>
<p>子生成器中有 return 语句时，返回一个值，在委托生成器中，通过含有 yield from 的表达式可以捕获那个值，如示例 17-26 所示。</p>
<p>示例 17-26　yield from 获取子生成器的返回值</p>
<blockquote>
<blockquote>
<blockquote>
<p>def sub_gen():<br>…     yield 1.1<br>…     yield 1.2<br>…     return ‘Done!’<br>…<br>def gen():<br>…     yield 1<br>…     result = yield from sub_gen()<br>…     print(‘&lt;–’, result)<br>…     yield 2<br>…<br>for x in gen():<br>…     print(x)<br>…<br>1<br>1.1<br>1.2<br>&lt;– Done!<br>2<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/54/2/4/734/1%3A0%29">2024/3/1 4:07 PM</a></p>
</blockquote>
</blockquote>
</blockquote>
<p>子生成器中的yield不是返回值</p>
<hr>
<h1 id="第-18-章-with、match-和-else-块"><a href="#第-18-章-with、match-和-else-块" class="headerlink" title="第 18 章　with、match 和 else 块"></a>第 18 章　with、match 和 else 块</h1><p>第 18 章　with、match 和 else 块<br><a href="calibre://view-book/_hex_-43616c696272655f4c696272617279/3/EPUB?open_at=epubcfi%28/56/2/4/2%5Bnav_point_383%5D/1%3A0%29">2024/3/1 5:04 PM</a></p>
<p>本书暂时读到此章节，后续需要进阶再读</p>
<hr>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E2%9C%B0%E2%9C%B0%E2%9C%B0%E2%9C%B0%E2%9C%B0/" rel="tag"># ✰✰✰✰✰</a>
              <a href="/tags/%E2%80%BB%E2%80%BB%E2%80%BB/" rel="tag"># ※※※</a>
              <a href="/tags/OReilly/" rel="tag"># OReilly</a>
              <a href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag"># 技术</a>
              <a href="/tags/python/" rel="tag"># python</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/03/01/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6/%E4%B8%80%E7%BB%9F%E6%B1%9F%E5%B1%B1%E4%B9%8B%E5%90%8E%EF%BC%9A%E5%A4%A7%E6%98%8E%E5%85%B4%E4%BA%A1%E4%B9%8B%E8%B0%9C%EF%BC%88%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E5%87%BA%E5%93%81%EF%BC%89/" rel="prev" title="微信读书/一统江山之后：大明兴亡之谜（微信读书出品）">
      <i class="fa fa-chevron-left"></i> 微信读书/一统江山之后：大明兴亡之谜（微信读书出品）
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/03/13/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6/%E8%A1%80%E9%85%AC%E5%AE%9A%E5%BE%8B%EF%BC%9A%E4%B8%AD%E5%9B%BD%E5%8E%86%E5%8F%B2%E4%B8%AD%E7%9A%84%E7%94%9F%E5%AD%98%E6%B8%B8%E6%88%8F/" rel="next" title="微信读书/血酬定律：中国历史中的生存游戏">
      微信读书/血酬定律：中国历史中的生存游戏 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-1-章-Python-数据模型"><span class="nav-number">2.</span> <span class="nav-text">第 1 章　Python 数据模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-一摞-Python-风格的纸牌"><span class="nav-number">2.1.</span> <span class="nav-text">1.2　一摞 Python 风格的纸牌</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-特殊方法是如何使用的"><span class="nav-number">2.2.</span> <span class="nav-text">1.3　特殊方法是如何使用的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-2-字符串表示形式"><span class="nav-number">2.2.1.</span> <span class="nav-text">1.3.2　字符串表示形式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-4-容器-API"><span class="nav-number">2.2.2.</span> <span class="nav-text">1.3.4　容器 API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-特殊方法概述"><span class="nav-number">2.3.</span> <span class="nav-text">1.4　特殊方法概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-len-为什么不是方法"><span class="nav-number">2.4.</span> <span class="nav-text">1.5　len 为什么不是方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-2-章-丰富的序列"><span class="nav-number">3.</span> <span class="nav-text">第 2 章　丰富的序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-内置序列类型概览"><span class="nav-number">3.1.</span> <span class="nav-text">2.2　内置序列类型概览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-列表推导式和生成器表达式"><span class="nav-number">3.2.</span> <span class="nav-text">2.3　列表推导式和生成器表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-列表推导式对可读性的影响"><span class="nav-number">3.2.1.</span> <span class="nav-text">2.3.1　列表推导式对可读性的影响</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-列表推导式与-map-和-filter-比较"><span class="nav-number">3.2.2.</span> <span class="nav-text">2.3.2　列表推导式与 map 和 filter 比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3-笛卡儿积"><span class="nav-number">3.2.3.</span> <span class="nav-text">2.3.3　笛卡儿积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-4-生成器表达式"><span class="nav-number">3.2.4.</span> <span class="nav-text">2.3.4　生成器表达式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-元组不仅仅是不可变列表"><span class="nav-number">3.3.</span> <span class="nav-text">2.4　元组不仅仅是不可变列表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-1-用作记录"><span class="nav-number">3.3.1.</span> <span class="nav-text">2.4.1　用作记录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-2-用作不可变列表"><span class="nav-number">3.3.2.</span> <span class="nav-text">2.4.2　用作不可变列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-3-列表和元组方法的比较"><span class="nav-number">3.3.3.</span> <span class="nav-text">2.4.3　列表和元组方法的比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-序列和可迭代对象拆包"><span class="nav-number">3.4.</span> <span class="nav-text">2.5　序列和可迭代对象拆包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-1-使用-获取余下的项"><span class="nav-number">3.4.1.</span> <span class="nav-text">2.5.1　使用 * 获取余下的项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-3-嵌套拆包"><span class="nav-number">3.4.2.</span> <span class="nav-text">2.5.3　嵌套拆包</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7-切片"><span class="nav-number">3.5.</span> <span class="nav-text">2.7　切片</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-1-为什么切片和区间排除最后一项"><span class="nav-number">3.5.1.</span> <span class="nav-text">2.7.1　为什么切片和区间排除最后一项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-4-为切片赋值"><span class="nav-number">3.5.2.</span> <span class="nav-text">2.7.4　为切片赋值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-8-使用-和-处理序列"><span class="nav-number">3.6.</span> <span class="nav-text">2.8　使用 + 和 * 处理序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-9-list-sort-与内置函数-sorted"><span class="nav-number">3.7.</span> <span class="nav-text">2.9　list.sort 与内置函数 sorted</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-10-当列表不适用时"><span class="nav-number">3.8.</span> <span class="nav-text">2.10　当列表不适用时</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-10-1-数组"><span class="nav-number">3.8.1.</span> <span class="nav-text">2.10.1　数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-10-3-NumPy"><span class="nav-number">3.8.2.</span> <span class="nav-text">2.10.3　NumPy</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-11-本章小结"><span class="nav-number">3.9.</span> <span class="nav-text">2.11　本章小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-12-延伸阅读"><span class="nav-number">3.10.</span> <span class="nav-text">2.12　延伸阅读</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-3-章-字典和集合"><span class="nav-number">4.</span> <span class="nav-text">第 3 章　字典和集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-本章新增内容"><span class="nav-number">4.1.</span> <span class="nav-text">3.1　本章新增内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-字典的现代句法"><span class="nav-number">4.2.</span> <span class="nav-text">3.2　字典的现代句法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-字典推导式"><span class="nav-number">4.2.1.</span> <span class="nav-text">3.2.1　字典推导式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-8-字典视图"><span class="nav-number">4.3.</span> <span class="nav-text">3.8　字典视图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-10-集合论"><span class="nav-number">4.4.</span> <span class="nav-text">3.10　集合论</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-5-章-数据类构建器"><span class="nav-number">5.</span> <span class="nav-text">第 5 章　数据类构建器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-数据类构建器概述"><span class="nav-number">5.1.</span> <span class="nav-text">5.2　数据类构建器概述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-6-章-对象引用、可变性和垃圾回收"><span class="nav-number">6.</span> <span class="nav-text">第 6 章　对象引用、可变性和垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-6-del-和垃圾回收"><span class="nav-number">6.1.</span> <span class="nav-text">6.6　del 和垃圾回收</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-7-章-函数是一等对象"><span class="nav-number">7.</span> <span class="nav-text">第 7 章　函数是一等对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-高阶函数"><span class="nav-number">7.1.</span> <span class="nav-text">7.3　高阶函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#map、filter-和-reduce-的现代替代品"><span class="nav-number">7.1.1.</span> <span class="nav-text">map、filter 和 reduce 的现代替代品</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5-9-种可调用对象"><span class="nav-number">7.2.</span> <span class="nav-text">7.5　9 种可调用对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-10-延伸阅读"><span class="nav-number">7.3.</span> <span class="nav-text">7.10　延伸阅读</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-10-章-使用一等函数实现设计模式"><span class="nav-number">8.</span> <span class="nav-text">第 10 章　使用一等函数实现设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-2-案例分析：重构策略模式"><span class="nav-number">8.1.</span> <span class="nav-text">10.2　案例分析：重构策略模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-1-经典的策略模式"><span class="nav-number">8.1.1.</span> <span class="nav-text">10.2.1　经典的策略模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-11-章-符合-Python-风格的对象"><span class="nav-number">9.</span> <span class="nav-text">第 11 章　符合 Python 风格的对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#11-5-classmethod-与-staticmethod"><span class="nav-number">9.1.</span> <span class="nav-text">11.5　classmethod 与 staticmethod</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-17-章-迭代器、生成器和经典协程"><span class="nav-number">10.</span> <span class="nav-text">第 17 章　迭代器、生成器和经典协程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#17-5-为-Sentence-类实现-iter-方法"><span class="nav-number">10.1.</span> <span class="nav-text">17.5　为 Sentence 类实现 iter 方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#17-5-4-生成器的工作原理"><span class="nav-number">10.1.1.</span> <span class="nav-text">17.5.4　生成器的工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-11-yield-from：从子生成器中产出"><span class="nav-number">10.2.</span> <span class="nav-text">17.11　yield from：从子生成器中产出</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-18-章-with、match-和-else-块"><span class="nav-number">11.</span> <span class="nav-text">第 18 章　with、match 和 else 块</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="郭富城"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">郭富城</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">189</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">107</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/gxianch" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gxianch" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/%E5%8F%91%E9%82%AE%E4%BB%B6%E8%87%B3:g.xian.ch@gmail.com" title="E-Mail → 发邮件至:g.xian.ch@gmail.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://book4you.org/" title="https:&#x2F;&#x2F;book4you.org&#x2F;" rel="noopener" target="_blank">ZLibrary</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.banshujiang.cn/" title="http:&#x2F;&#x2F;www.banshujiang.cn&#x2F;" rel="noopener" target="_blank">banshujiang</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.packtpub.com/tech" title="https:&#x2F;&#x2F;www.packtpub.com&#x2F;tech" rel="noopener" target="_blank">packtpub</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.manning.com/" title="https:&#x2F;&#x2F;www.manning.com&#x2F;" rel="noopener" target="_blank">manning</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://coolshell.cn/" title="https:&#x2F;&#x2F;coolshell.cn&#x2F;" rel="noopener" target="_blank">coolshell</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">郭富城</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
