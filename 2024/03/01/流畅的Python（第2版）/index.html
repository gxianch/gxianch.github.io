<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="前言本地jupyter打开 12(base) xian@guofuchengdeMacBook-Pro ~ % conda activate base(base) xian@guofuchengdeMacBook-Pro ~ % jupyter notebook http:&#x2F;&#x2F;localhost:8888&#x2F;tree&#x2F;PycharmProjects&#x2F;book&#x2F;example-code-2e 第 1">
<meta property="og:type" content="article">
<meta property="og:title" content="流畅的Python（第2版）">
<meta property="og:url" content="http://yoursite.com/2024/03/01/%E6%B5%81%E7%95%85%E7%9A%84Python%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89/index.html">
<meta property="og:site_name" content="郭富城的博客">
<meta property="og:description" content="前言本地jupyter打开 12(base) xian@guofuchengdeMacBook-Pro ~ % conda activate base(base) xian@guofuchengdeMacBook-Pro ~ % jupyter notebook http:&#x2F;&#x2F;localhost:8888&#x2F;tree&#x2F;PycharmProjects&#x2F;book&#x2F;example-code-2e 第 1">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-03-01T06:30:13.000Z">
<meta property="article:modified_time" content="2024-07-12T13:56:14.103Z">
<meta property="article:author" content="郭富城">
<meta property="article:tag" content="✰✰✰✰✰">
<meta property="article:tag" content="OReilly">
<meta property="article:tag" content="python">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2024/03/01/%E6%B5%81%E7%95%85%E7%9A%84Python%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>流畅的Python（第2版） | 郭富城的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">郭富城的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">阅读书籍笔记,不定期更新</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home  //首页"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive   //归档"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags   //标签"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th  //分类"></i>分类</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/03/01/%E6%B5%81%E7%95%85%E7%9A%84Python%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="郭富城">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="郭富城的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          流畅的Python（第2版）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-01 14:30:13" itemprop="dateCreated datePublished" datetime="2024-03-01T14:30:13+08:00">2024-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-12 21:56:14" itemprop="dateModified" datetime="2024-07-12T21:56:14+08:00">2024-07-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本地jupyter打开</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(base) xian@guofuchengdeMacBook-Pro ~ % conda activate base</span><br><span class="line">(base) xian@guofuchengdeMacBook-Pro ~ % jupyter notebook</span><br></pre></td></tr></table></figure>
<p><a href="http://localhost:8888/tree/PycharmProjects/book/example-code-2e" target="_blank" rel="noopener">http://localhost:8888/tree/PycharmProjects/book/example-code-2e</a></p>
<h1 id="第-1-章-Python-数据模型"><a href="#第-1-章-Python-数据模型" class="headerlink" title="第 1 章　Python 数据模型"></a>第 1 章　Python 数据模型</h1><h3 id="不使用-collection-len-，而是使用-len-collection"><a href="#不使用-collection-len-，而是使用-len-collection" class="headerlink" title="不使用 collection.len()，而是使用 len(collection)"></a>不使用 collection.len()，而是使用 len(collection)</h3><p>这一点表面上看确实奇怪，而且只是众多奇怪行为的冰山一角，不过知道背后的原因之后，你会发现这才真正符合“Python 风格”。一切的一切都埋藏在 Python 数据模型中。我们平常自己创建对象时就要使用这个 API，确保使用最地道的语言功能。</p>
<h3 id="特殊方法的名称前后两端都有双下划线。"><a href="#特殊方法的名称前后两端都有双下划线。" class="headerlink" title="特殊方法的名称前后两端都有双下划线。"></a>特殊方法的名称前后两端都有双下划线。</h3><p>例如，在 obj[key] 句法背后提供支持的是特殊方法 <strong>getitem</strong>。为了求解 my_collection[key]，Python 解释器要调用 my_collection.<strong>getitem</strong>(key)。</p>
<h2 id="1-2-一摞-Python-风格的纸牌"><a href="#1-2-一摞-Python-风格的纸牌" class="headerlink" title="1.2　一摞 Python 风格的纸牌"></a>1.2　一摞 Python 风格的纸牌</h2><h3 id="两个for循环"><a href="#两个for循环" class="headerlink" title="两个for循环"></a>两个for循环</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self._cards = [Card(rank, suit) <span class="keyword">for</span> suit <span class="keyword">in</span> self.suits</span><br><span class="line">                                        <span class="keyword">for</span> rank <span class="keyword">in</span> self.ranks]</span><br></pre></td></tr></table></figure>


<h2 id="1-3-特殊方法是如何使用的"><a href="#1-3-特殊方法是如何使用的" class="headerlink" title="1.3　特殊方法是如何使用的"></a>1.3　特殊方法是如何使用的</h2><p>我们在编写代码时一般不直接调用特殊方法，除非涉及大量元编程。即便如此，大部分时间也是实现特殊方法，很少显式调用。唯一例外的是 <strong>init</strong> 方法，为自定义的类实现 <strong>init</strong> 方法时经常直接调用它调取超类的初始化方法。</p>
<h3 id="1-3-2-字符串表示形式"><a href="#1-3-2-字符串表示形式" class="headerlink" title="1.3.2　字符串表示形式"></a>1.3.2　字符串表示形式</h3><p>特殊方法 <strong>repr</strong> 供内置函数 repr 调用，获取对象的字符串表示形式。如未定义 <strong>repr</strong> 方法，Vector 实例在 Python 控制台中显示为 &lt;Vector object at 0x10e100070&gt; 形式。</p>
<p>与此形成对照的是，<strong>str</strong> 方法由内置函数 str() 调用，在背后供 print 函数使用，返回对终端用户友好的字符串。</p>
<p>有时，<strong>repr</strong> 方法返回的字符串足够友好，无须再定义 <strong>str</strong> 方法</p>
<p>如果你熟悉的编程语言使用 toString 方法，那么你可能习惯实现 <strong>str</strong> 方法而不是 <strong>repr</strong> 方法。在 Python 中，如果必须二选一的话，请选择 <strong>repr</strong> 方法。</p>
<h3 id="1-3-4-集合-API"><a href="#1-3-4-集合-API" class="headerlink" title="1.3.4　集合 API"></a>1.3.4　集合 API</h3><p>图 1-2：基本集合类型的 UML 类图。以斜体显示的方法名称表示抽象方法，必须由具体子类（例如 list 和 dict）实现。其他方法有具体实现，子类可以直接继承</p>
<p>Python 不强制要求具体类继承这些抽象基类中的任何一个。只要实现了 <strong>len</strong> 方法，就说明那个类满足 Sized 接口。</p>
<p>Collection 有 3 个十分重要的专用接口：</p>
<p>Sequence 规范 list 和 str 等内置类型的接口；<br>Mapping 被 dict、collections.defaultdict 等实现；<br>Set 是 set 和 frozenset 两个内置类型的接口。<br>只有 Sequence 实现了 Reversible，因为序列要支持以任意顺序排列内容，而 Mapping 和 Set 不需要。</p>
<p>自 Python 3.7 开始，dict 类型正式“有顺序”了，不过只是保留键的插入顺序。你不能随意重新排列 dict 中的键。</p>
<h1 id="第-2-章-丰富的序列"><a href="#第-2-章-丰富的序列" class="headerlink" title="第 2 章　丰富的序列"></a>第 2 章　丰富的序列</h1><h2 id="2-2-内置序列类型概览"><a href="#2-2-内置序列类型概览" class="headerlink" title="2.2　内置序列类型概览"></a>2.2　内置序列类型概览</h2><p>Python 标准库用 C 语言实现了丰富的序列类型，列举如下。</p>
<p>集合序列</p>
<p>　　可存放不同类型的项，其中包括嵌套集合。示例：list、tuple 和 collections.deque。</p>
<p>扁平序列</p>
<p>　　可存放一种简单类型的项。示例：str、bytes 和 array.array。</p>
<p>图 2-1：图中展示的是一个元组和一个数组的内存简图，它们各有 3 项。灰色方块（未按比例绘制）表示各个 Python 对象的内存标头。元组中的每一项都是引用，引用的是不同的 Python 对象，对象中还可以存放其他 Python 对象的引用，例如那个包含两个项的列表。相比之下，Python 中的数组整体是一个对象，存放一个 C 语言数组，包含 3 个双精度数</p>
<p>因此，扁平序列更加紧凑，但是只能存放原始机器值，例如字节、整数和浮点数。</p>
<p>还可按可变性对序列类型分类。</p>
<p>可变序列</p>
<p>　　例如 list、bytearray、array.array 和 collections.deque。</p>
<p>不可变序列</p>
<p>　　例如 tuple、str 和 bytes。</p>
<p>记住不同序列类型的共同点：有些是可变的，有些是不可变的；有些是集合，有些是扁平的。这有助于你把相关概念延伸到不太熟悉的序列类型上。</p>
<h2 id="2-3-列表推导式和生成器表达式"><a href="#2-3-列表推导式和生成器表达式" class="headerlink" title="2.3　列表推导式和生成器表达式"></a>2.3　列表推导式和生成器表达式</h2><h3 id="2-3-3-笛卡儿积"><a href="#2-3-3-笛卡儿积" class="headerlink" title="2.3.3　笛卡儿积"></a>2.3.3　笛卡儿积</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'black'</span>, <span class="string">'white'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sizes = [<span class="string">'S'</span>, <span class="string">'M'</span>, <span class="string">'L'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tshirts = [(color, size) <span class="keyword">for</span> color <span class="keyword">in</span> colors <span class="keyword">for</span> size <span class="keyword">in</span> sizes]  ❶</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tshirts</span><br><span class="line">[(<span class="string">'black'</span>, <span class="string">'S'</span>), (<span class="string">'black'</span>, <span class="string">'M'</span>), (<span class="string">'black'</span>, <span class="string">'L'</span>), (<span class="string">'white'</span>, <span class="string">'S'</span>),</span><br><span class="line">    (<span class="string">'white'</span>, <span class="string">'M'</span>), (<span class="string">'white'</span>, <span class="string">'L'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> color <span class="keyword">in</span> colors:  ❷</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> size <span class="keyword">in</span> sizes:</span><br><span class="line"><span class="meta">... </span>        print((color, size))</span><br><span class="line">...</span><br><span class="line">(<span class="string">'black'</span>, <span class="string">'S'</span>)</span><br><span class="line">(<span class="string">'black'</span>, <span class="string">'M'</span>)</span><br><span class="line">(<span class="string">'black'</span>, <span class="string">'L'</span>)</span><br><span class="line">(<span class="string">'white'</span>, <span class="string">'S'</span>)</span><br><span class="line">(<span class="string">'white'</span>, <span class="string">'M'</span>)</span><br><span class="line">(<span class="string">'white'</span>, <span class="string">'L'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tshirts = [(color, size) <span class="keyword">for</span> size <span class="keyword">in</span> sizes      ❸</span><br><span class="line"><span class="meta">... </span>                         <span class="keyword">for</span> color <span class="keyword">in</span> colors]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tshirts</span><br><span class="line">[(<span class="string">'black'</span>, <span class="string">'S'</span>), (<span class="string">'white'</span>, <span class="string">'S'</span>), (<span class="string">'black'</span>, <span class="string">'M'</span>), (<span class="string">'white'</span>, <span class="string">'M'</span>),</span><br><span class="line">    (<span class="string">'black'</span>, <span class="string">'L'</span>), (<span class="string">'white'</span>, <span class="string">'L'</span>)]</span><br></pre></td></tr></table></figure>
<p>❶ 先按颜色再按尺寸排列，生成一个元组列表。</p>
<p>❷ 注意，这里两个循环的嵌套方式与列表推导式中 for 子句的先后顺序一样。</p>
<p>❸ 如果想先按尺寸再按颜色排列，则只需要调整 for 子句的顺序。我在这里插入了一个换行符，这样排列顺序就更明显了。</p>
<h2 id="2-4-元组不仅仅是不可变列表"><a href="#2-4-元组不仅仅是不可变列表" class="headerlink" title="2.4　元组不仅仅是不可变列表"></a>2.4　元组不仅仅是不可变列表</h2><p>2.4　元组不仅仅是不可变列表<br>有些 Python 入门教程把元组称为“不可变列表”，然而这没有完全概括元组的特点。元组有两个作用，除了可以作为不可变列表使用之外，还可用作没有字段名称的记录。</p>
<p>元组是列表的延伸，列表内部是单个元素，元祖内部元素可以是多个</p>
<h3 id="2-4-1-用作记录"><a href="#2-4-1-用作记录" class="headerlink" title="2.4.1　用作记录"></a>2.4.1　用作记录</h3><p>示例 2-7　把元组当作记录使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lax_coordinates = (<span class="number">33.9425</span>, <span class="number">-118.408056</span>)  ❶</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>city, year, pop, chg, area = (<span class="string">'Tokyo'</span>, <span class="number">2003</span>, <span class="number">32</span>_450, <span class="number">0.66</span>, <span class="number">8014</span>)  ❷</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>traveler_ids = [(<span class="string">'USA'</span>, <span class="string">'31195855'</span>), (<span class="string">'BRA'</span>, <span class="string">'CE342567'</span>),  ❸</span><br><span class="line"><span class="meta">... </span>    (<span class="string">'ESP'</span>, <span class="string">'XDA205856'</span>)]</span><br></pre></td></tr></table></figure>

<p>一个元组列表，元组的形式为 (country_code, passport_number)。<br>仅使用一个语句就把 (‘Tokyo’, 2003, 32_450, 0.66, 8014) 赋值给了 city, year, pop, chg, area。</p>
<h3 id="2-4-3-列表和元组方法的比较"><a href="#2-4-3-列表和元组方法的比较" class="headerlink" title="2.4.3　列表和元组方法的比较"></a>2.4.3　列表和元组方法的比较</h3><p>把元组当作列表的不可变变体使用时，有必要了解二者 API 之间的异同。从表 2-1 可以看出，元组支持所有不涉及增删项的列表方法，而且元组没有 <strong>reversed</strong> 方法。</p>
<h2 id="2-5-序列和可迭代对象拆包"><a href="#2-5-序列和可迭代对象拆包" class="headerlink" title="2.5　序列和可迭代对象拆包"></a>2.5　序列和可迭代对象拆包</h2><p>最明显的拆包形式是并行赋值（parallel assignment），即把可迭代对象中的项赋值给变量元组，如以下示例所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lax_coordinates = (<span class="number">33.9425</span>, <span class="number">-118.408056</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>latitude, longitude = lax_coordinates  <span class="comment"># 拆包</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>latitude</span><br><span class="line"><span class="number">33.9425</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>longitude</span><br><span class="line"><span class="number">-118.408056</span></span><br><span class="line">利用拆包还可以轻松对调两个变量的值，省掉中间的临时变量。</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b, a = a, b</span><br><span class="line">调用函数时在参数前面加上一个 *，利用的也是拆包。</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>divmod(<span class="number">20</span>, <span class="number">8</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">20</span>, <span class="number">8</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>divmod(*t)</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>quotient, remainder = divmod(*t)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>quotient, remainder</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">上述代码还展示了拆包的另一个用途：为函数返回多个值提供一种便于调用方使用的方式。再举一个例子：os.path.split() 函数根据传入的文件系统路径构建元组 (path, last_part)。</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_, filename = os.path.split(<span class="string">'/home/luciano/.ssh/id_rsa.pub'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>filename</span><br><span class="line"><span class="string">'id_rsa.pub'</span></span><br><span class="line">如果只需要拆包得到的部分项，那么还可以使用 <span class="number">2.5</span><span class="number">.1</span> 节介绍的 * 句法。</span><br></pre></td></tr></table></figure>


<h3 id="2-5-1-使用-获取余下的项"><a href="#2-5-1-使用-获取余下的项" class="headerlink" title="2.5.1　使用 * 获取余下的项"></a>2.5.1　使用 * 获取余下的项</h3><p>2.5.1　使用 * 获取余下的项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定义函数时可以使用 *args 捕获余下的任意数量的参数，这是 Python 的一个经典特性。</span><br></pre></td></tr></table></figure>

<p>Python 3 把这一思想延伸到了并行赋值上。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, *rest = range(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, rest</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, *rest = range(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, rest</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, [<span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, *rest = range(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, rest</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, [])</span><br></pre></td></tr></table></figure>

<h3 id="2-5-3-嵌套拆包"><a href="#2-5-3-嵌套拆包" class="headerlink" title="2.5.3　嵌套拆包"></a>2.5.3　嵌套拆包</h3><p>2.5.3　嵌套拆包<br>拆包的对象可以嵌套，例如 (a, b, (c, d))。如果值的嵌套结构是相同的，则 Python 能正确处理。示例 2-8 演示了嵌套拆包的具体用法。</p>
<p>示例 2-8　拆包嵌套元组，获取经度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">metro_areas = [</span><br><span class="line">    (<span class="string">'Tokyo'</span>, <span class="string">'JP'</span>, <span class="number">36.933</span>, (<span class="number">35.689722</span>, <span class="number">139.691667</span>)),  ❶</span><br><span class="line">    (<span class="string">'Delhi NCR'</span>, <span class="string">'IN'</span>, <span class="number">21.935</span>, (<span class="number">28.613889</span>, <span class="number">77.208889</span>)),</span><br><span class="line">    (<span class="string">'Mexico City'</span>, <span class="string">'MX'</span>, <span class="number">20.142</span>, (<span class="number">19.433333</span>, <span class="number">-99.133333</span>)),</span><br><span class="line">    (<span class="string">'New York-Newark'</span>, <span class="string">'US'</span>, <span class="number">20.104</span>, (<span class="number">40.808611</span>, <span class="number">-74.020386</span>)),</span><br><span class="line">    (<span class="string">'São Paulo'</span>, <span class="string">'BR'</span>, <span class="number">19.649</span>, (<span class="number">-23.547778</span>, <span class="number">-46.635833</span>)),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, _, _, (lat, lon) <span class="keyword">in</span> metro_areas:  ❷</span><br></pre></td></tr></table></figure>




<h2 id="2-7-切片"><a href="#2-7-切片" class="headerlink" title="2.7　切片"></a>2.7　切片</h2><p>2.7　切片<br>在 Python 中，列表、元组、字符串等所有序列类型都支持切片操作。切片比多数人认为的要强大很多。</p>
<h3 id="2-7-1-为什么切片和区间排除最后一项"><a href="#2-7-1-为什么切片和区间排除最后一项" class="headerlink" title="2.7.1　为什么切片和区间排除最后一项"></a>2.7.1　为什么切片和区间排除最后一项</h3><p>方便在索引 x 处把一个序列拆分成两部分而不产生重叠，直接使用 my_list[:x] 和 my_list[x:] 即可。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[:<span class="number">2</span>]  <span class="comment"># 在索引位2处拆分</span></span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">2</span>:]</span><br><span class="line">[<span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[:<span class="number">3</span>]  <span class="comment"># 在索引位3处拆分</span></span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">3</span>:]</span><br><span class="line">[<span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>]</span><br></pre></td></tr></table></figure>


<h3 id="2-7-4-为切片赋值"><a href="#2-7-4-为切片赋值" class="headerlink" title="2.7.4　为切片赋值"></a>2.7.4　为切片赋值</h3><p>2.7.4　为切片赋值<br>在赋值语句的左侧使用切片表示法，或者作为 del 语句的目标，可以就地移植、切除或以其他方式修改可变序列。下面举几个例子演示这种表示法的强大功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = list(range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">2</span>:<span class="number">5</span>] = [<span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> l[<span class="number">5</span>:<span class="number">7</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>


<h2 id="2-8-使用-和-处理序列"><a href="#2-8-使用-和-处理序列" class="headerlink" title="2.8　使用 + 和 * 处理序列"></a>2.8　使用 + 和 * 处理序列</h2><p>2.8　使用 + 和 * 处理序列<br>Python 程序员预期序列支持 + 和 *。通常，+ 的两个运算对象必须是同一种序列，而且都不可修改，拼接的结果是一个同类型的新序列。</p>
<p>如果想多次拼接同一个序列，可以乘以一个整数。同样，结果是一个新创建的序列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l * <span class="number">5</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> * <span class="string">'abcd'</span></span><br><span class="line"><span class="string">'abcdabcdabcdabcdabcd'</span></span><br><span class="line">+ 和 * 始终创建一个新对象，绝不更改操作数。</span><br></pre></td></tr></table></figure>


<h2 id="2-9-list-sort-与内置函数-sorted"><a href="#2-9-list-sort-与内置函数-sorted" class="headerlink" title="2.9　list.sort 与内置函数 sorted"></a>2.9　list.sort 与内置函数 sorted</h2><h3 id="list-sort-方法就地排序列表，即不创建副本。返回值为-None"><a href="#list-sort-方法就地排序列表，即不创建副本。返回值为-None" class="headerlink" title="list.sort 方法就地排序列表，即不创建副本。返回值为 None"></a>list.sort 方法就地排序列表，即不创建副本。返回值为 None</h3><p>，目的就是提醒我们，它更改了接收者，11 没有创建新列表。这是 Python API 的一个重要约定：就地更改对象的函数或方法应该返回 None，让调用方清楚地知道接收者已被更改，没有创建新对象。</p>
<h3 id="内置函数-sorted-返回创建的新列表"><a href="#内置函数-sorted-返回创建的新列表" class="headerlink" title="内置函数 sorted 返回创建的新列表"></a>内置函数 sorted 返回创建的新列表</h3><h2 id="2-10-当列表不适用时"><a href="#2-10-当列表不适用时" class="headerlink" title="2.10　当列表不适用时"></a>2.10　当列表不适用时</h2><h3 id="经常需要在列表的两端添加和删除项，使用-deque（double-ended-queue，双端队列）"><a href="#经常需要在列表的两端添加和删除项，使用-deque（double-ended-queue，双端队列）" class="headerlink" title="经常需要在列表的两端添加和删除项，使用 deque（double-ended queue，双端队列）"></a>经常需要在列表的两端添加和删除项，使用 deque（double-ended queue，双端队列）</h3><p>list 类型简单灵活，不过，针对具体的需求，或许还有更好的选择。例如，使用数组处理上百万个浮点值可以节省大量内存。另外，如果经常需要在列表的两端添加和删除项，使用 deque（double-ended queue，双端队列）更合适，这是一种更高效的 FIFO14 数据结构。</p>
<h3 id="经常检查集合中是否存在某一项–使用set-类型"><a href="#经常检查集合中是否存在某一项–使用set-类型" class="headerlink" title="经常检查集合中是否存在某一项–使用set 类型"></a>经常检查集合中是否存在某一项–使用set 类型</h3><p>如果你在代码中经常检查集合中是否存在某一项（例如 item in my_collection），应考虑使用 set 类型存储 my_collection，尤其是项数较多的情况。Python 对 set 成员检查做了优化，速度更快。set 也是可迭代对象，但不是序列，因为 set 中的项是无序的</p>
<h3 id="2-10-1-数组"><a href="#2-10-1-数组" class="headerlink" title="2.10.1　数组"></a>2.10.1　数组</h3><h2 id="array-array-–-列表只包含数值"><a href="#array-array-–-列表只包含数值" class="headerlink" title="array.array – 列表只包含数值"></a>array.array – 列表只包含数值</h2><p>如果一个列表只包含数值，那么使用 array.array 会更高效。数组支持所有可变序列操作（包括 .pop、.insert 和 .extend），此外还有快速加载项和保存项的方法，例如 .frombytes 和 .tofile。</p>
<h3 id="2-10-3-NumPy"><a href="#2-10-3-NumPy" class="headerlink" title="2.10.3　NumPy"></a>2.10.3　NumPy</h3><p>示例 2-22 简单演示 NumPy 的用法，对二维数组做了些基本操作。</p>
<p>示例 2-22　numpy.ndarray 中行和列的基本操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np ❶</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">12</span>)  ❷</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(a)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">numpy</span>.<span class="title">ndarray</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">a</span>.<span class="title">shape</span>  ❸</span></span><br><span class="line"><span class="class"><span class="params">(<span class="number">12</span>,)</span></span></span><br><span class="line">&gt;&gt;&gt; a.shape = 3, 4  ❹</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>]  ❺</span><br><span class="line">array([ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>, <span class="number">1</span>]  ❻</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[:, <span class="number">1</span>]  ❼</span><br><span class="line">array([<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.transpose()  ❽</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">4</span>,  <span class="number">8</span>],</span><br><span class="line">       [ <span class="number">1</span>,  <span class="number">5</span>,  <span class="number">9</span>],</span><br><span class="line">       [ <span class="number">2</span>,  <span class="number">6</span>, <span class="number">10</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">7</span>, <span class="number">11</span>]])</span><br></pre></td></tr></table></figure>


<p>NumPy 和 SciPy 这两个库的功能异常强大，为很多优秀的工具提供了坚实的基础，例如 Pandas 和 scikit-learn。Pandas 实现的高效数组类型可以保存非数值数据，此外还支持导入和导出多种格式，包括 .csv、.xls、SQL 转储、HDF5 等。scikit-learn 是目前最广泛使用的机器学习工具集。</p>
<h2 id="2-11-本章小结"><a href="#2-11-本章小结" class="headerlink" title="2.11　本章小结"></a>2.11　本章小结</h2><p>元组在 Python 中扮演两个角色，一是不具名字段记录，二是不可变列表。把元组当作不可变列表使用时请记住，仅当元组中的所有项也都是不可变对象时，才能保证元组值是固定的。在元组上调用 hash(t) 函数可以快速判断元组的值是否固定。如果 t 包含可变的项，则 hash(t) 抛出 TypeError。</p>
<p>把元组当作记录使用时，元组拆包是提取元组字段最安全、可读性最高的方法。除了元组之外，* 在许多上下文中还适用于列表和可迭代对象。</p>
<p>序列切片是最受欢迎的 Python 句法特性之一，其功能比许多人所想的还要强大。用户定义的序列甚至可以支持 NumPy 那种多维切片和省略号（…）表示法。通过切片赋值修改可变序列是极具表现力的操作。</p>
<h2 id="2-12-延伸阅读"><a href="#2-12-延伸阅读" class="headerlink" title="2.12　延伸阅读"></a>2.12　延伸阅读</h2><p>与列表不同，元组通常包含不同类型的项。这也符合常理：如果元组中的每一项都是一个字段，那么每个字段就可以具有不同的类型。</p>
<h1 id="第-3-章-字典和集合"><a href="#第-3-章-字典和集合" class="headerlink" title="第 3 章　字典和集合"></a>第 3 章　字典和集合</h1><h2 id="3-1-本章新增内容"><a href="#3-1-本章新增内容" class="headerlink" title="3.1　本章新增内容"></a>3.1　本章新增内容</h2><p>dict 和 set 的底层实现仍然依赖于哈希表，不过 dict 的代码有两项重要的优化，节省了内存，还能保留键的插入顺序。</p>
<h2 id="3-2-字典的现代句法"><a href="#3-2-字典的现代句法" class="headerlink" title="3.2　字典的现代句法"></a>3.2　字典的现代句法</h2><h3 id="3-2-1-字典推导式"><a href="#3-2-1-字典推导式" class="headerlink" title="3.2.1　字典推导式"></a>3.2.1　字典推导式</h3><p>3.2.1　字典推导式<br>自 Python 2.7 开始，列表推导式和生成器表达式经过改造，以适用于字典推导式（以及后文要讲的集合推导式）。字典推导式从任何可迭代对象中获取键值对，构建 dict 实例。示例 3-1 使用字典推导式根据同一个元组列表构建两个字典。</p>
<p>示例 3-1　字典推导式示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dial_codes = [                                                  ❶</span><br><span class="line"><span class="meta">... </span>    (<span class="number">880</span>, <span class="string">'Bangladesh'</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">55</span>,  <span class="string">'Brazil'</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">86</span>,  <span class="string">'China'</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">91</span>,  <span class="string">'India'</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">62</span>,  <span class="string">'Indonesia'</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">81</span>,  <span class="string">'Japan'</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">234</span>, <span class="string">'Nigeria'</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">92</span>,  <span class="string">'Pakistan'</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">7</span>,   <span class="string">'Russia'</span>),</span><br><span class="line"><span class="meta">... </span>    (<span class="number">1</span>,   <span class="string">'United States'</span>),</span><br><span class="line"><span class="meta">... </span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>country_dial = &#123;country: code <span class="keyword">for</span> code, country <span class="keyword">in</span> dial_codes&#125;  ❷</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>country_dial</span><br><span class="line">&#123;<span class="string">'Bangladesh'</span>: <span class="number">880</span>, <span class="string">'Brazil'</span>: <span class="number">55</span>, <span class="string">'China'</span>: <span class="number">86</span>, <span class="string">'India'</span>: <span class="number">91</span>, <span class="string">'Indonesia'</span>: <span class="number">62</span>,</span><br><span class="line"><span class="string">'Japan'</span>: <span class="number">81</span>, <span class="string">'Nigeria'</span>: <span class="number">234</span>, <span class="string">'Pakistan'</span>: <span class="number">92</span>, <span class="string">'Russia'</span>: <span class="number">7</span>, <span class="string">'United States'</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;code: country.upper()                                          ❸</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> country, code <span class="keyword">in</span> sorted(country_dial.items())</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> code &lt; <span class="number">70</span>&#125;</span><br><span class="line">&#123;<span class="number">55</span>: <span class="string">'BRAZIL'</span>, <span class="number">62</span>: <span class="string">'INDONESIA'</span>, <span class="number">7</span>: <span class="string">'RUSSIA'</span>, <span class="number">1</span>: <span class="string">'UNITED STATES'</span>&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-8-字典视图"><a href="#3-8-字典视图" class="headerlink" title="3.8　字典视图"></a>3.8　字典视图</h2><p>dict 的实例方法 .keys()、.values() 和 .items() 分别返回 dict_keys、dict_values 和 dict_items 类的实例。这些字典视图是 dict 内部实现使用的数据结构的只读投影。</p>
<h2 id="3-10-集合论"><a href="#3-10-集合论" class="headerlink" title="3.10　集合论"></a>3.10　集合论</h2><p>集合是一组唯一的对象。集合的基本作用是去除重复项。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="string">'spam'</span>, <span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="string">'spam'</span>, <span class="string">'bacon'</span>, <span class="string">'eggs'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set(l)</span><br><span class="line">&#123;<span class="string">'eggs'</span>, <span class="string">'spam'</span>, <span class="string">'bacon'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(set(l))</span><br><span class="line">[<span class="string">'eggs'</span>, <span class="string">'spam'</span>, <span class="string">'bacon'</span>]</span><br></pre></td></tr></table></figure>


<p>如果想去除重复项，同时保留每一项首次出现位置的顺序，那么现在使用普通的 dict 即可，如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict.fromkeys(l).keys()</span><br><span class="line">dict_keys([<span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="string">'bacon'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(dict.fromkeys(l).keys())</span><br><span class="line">[<span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="string">'bacon'</span>]</span><br></pre></td></tr></table></figure>



<h1 id="第-5-章-数据类构建器"><a href="#第-5-章-数据类构建器" class="headerlink" title="第 5 章　数据类构建器"></a>第 5 章　数据类构建器</h1><p>Python 提供了几种构建简单类的方式，这些类只是字段的集合，几乎没有额外功能。这种模式称为“数据类”（data class），dataclasses 包就支持该模式。</p>
<h2 id="5-2-数据类构建器概述"><a href="#5-2-数据类构建器概述" class="headerlink" title="5.2　数据类构建器概述"></a>5.2　数据类构建器概述</h2><h3 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h3><p>下面使用 namedtuple 构建 Coordinate 类。namedtuple 是一个工厂方法，使用指定的名称和字段构建 tuple 的子类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Coordinate = namedtuple(<span class="string">'Coordinate'</span>, <span class="string">'lat lon'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(Coordinate, tuple)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>moscow = Coordinate(<span class="number">55.756</span>, <span class="number">37.617</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>moscow</span><br><span class="line">Coordinate(lat=<span class="number">55.756</span>, lon=<span class="number">37.617</span>)  ❶</span><br></pre></td></tr></table></figure>


<h1 id="第-6-章-对象引用、可变性和垃圾回收"><a href="#第-6-章-对象引用、可变性和垃圾回收" class="headerlink" title="第 6 章　对象引用、可变性和垃圾回收"></a>第 6 章　对象引用、可变性和垃圾回收</h1><h2 id="6-6-del-和垃圾回收"><a href="#6-6-del-和垃圾回收" class="headerlink" title="6.6　del 和垃圾回收"></a>6.6　del 和垃圾回收</h2><p>del 语句删除引用，而不是对象。</p>
<h1 id="第-7-章-函数是一等对象"><a href="#第-7-章-函数是一等对象" class="headerlink" title="第 7 章　函数是一等对象"></a>第 7 章　函数是一等对象</h1><h2 id="7-3-高阶函数"><a href="#7-3-高阶函数" class="headerlink" title="7.3　高阶函数"></a>7.3　高阶函数</h2><h3 id="map、filter-和-reduce-的现代替代品"><a href="#map、filter-和-reduce-的现代替代品" class="headerlink" title="map、filter 和 reduce 的现代替代品"></a>map、filter 和 reduce 的现代替代品</h3><p>sum 和 reduce 的整体运作方式是一样的，即把某个操作连续应用到序列中的项上，累计前一个结果，把一系列值归约成一个值。</p>
<h2 id="7-5-9-种可调用对象"><a href="#7-5-9-种可调用对象" class="headerlink" title="7.5　9 种可调用对象"></a>7.5　9 种可调用对象</h2><p>生成器函数</p>
<p>　　主体中有 yield 关键字的函数或方法。调用生成器函数返回一个生成器对象。</p>
<p>原生协程函数</p>
<p>　　使用 async def 定义的函数或方法。调用原生协程函数返回一个协程对象。Python 3.5 新增。</p>
<p>异步生成器函数</p>
<p>　　使用 async def 定义，而且主体中有 yield 关键字的函数或方法。调用异步生成器函数返回一个异步生成器，供 async for 使用。Python 3.6 新增。</p>
<p>与其他可调用对象不同，生成器、原生协程和异步生成器函数的返回值不是应用程序数据，而是需要进一步处理的对象，要么产出应用程序数据，要么执行某种操作。生成器函数会返回迭代器（详见第 17 章）。原生协程函数和异步生成器函数返回的对象只能由异步编程框架（例如 asyncio）处理（详见第 21 章）。</p>
<h2 id="7-10-延伸阅读"><a href="#7-10-延伸阅读" class="headerlink" title="7.10　延伸阅读"></a>7.10　延伸阅读</h2><p>函数有名称，栈跟踪更易于阅读。匿名函数是一种便利的简洁方式，人们乐于使用它们，但是有时会忘乎所以，尤其是在鼓励深层嵌套匿名函数的语言和环境中，例如 Node.js 之上的 JavaScript。匿名函数嵌套的层级太深，不利于调试和处理错误。</p>
<h1 id="第-10-章-使用一等函数实现设计模式"><a href="#第-10-章-使用一等函数实现设计模式" class="headerlink" title="第 10 章　使用一等函数实现设计模式"></a>第 10 章　使用一等函数实现设计模式</h1><h2 id="10-2-案例分析：重构策略模式"><a href="#10-2-案例分析：重构策略模式" class="headerlink" title="10.2　案例分析：重构策略模式"></a>10.2　案例分析：重构策略模式</h2><h3 id="10-2-1-经典的策略模式"><a href="#10-2-1-经典的策略模式" class="headerlink" title="10.2.1　经典的策略模式"></a>10.2.1　经典的策略模式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promotion</span><span class="params">(ABC)</span>:</span>  <span class="comment"># 策略：抽象基类</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">discount</span><span class="params">(self, order: Order)</span> -&gt; Decimal:</span></span><br><span class="line">        <span class="string">"""返回折扣金额（正值）"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FidelityPromo</span><span class="params">(Promotion)</span>:</span>  <span class="comment"># 第一个具体策略</span></span><br><span class="line">    <span class="string">"""为积分为1000或以上的顾客提供5%折扣"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">discount</span><span class="params">(self, order: Order)</span> -&gt; Decimal:</span></span><br><span class="line">        rate = Decimal(<span class="string">'0.05'</span>)</span><br><span class="line">        <span class="keyword">if</span> order.customer.fidelity &gt;= <span class="number">1000</span>:</span><br><span class="line">            <span class="keyword">return</span> order.total() * rate</span><br><span class="line">        <span class="keyword">return</span> Decimal(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>


<h1 id="第-11-章-符合-Python-风格的对象"><a href="#第-11-章-符合-Python-风格的对象" class="headerlink" title="第 11 章　符合 Python 风格的对象"></a>第 11 章　符合 Python 风格的对象</h1><h2 id="11-5-classmethod-与-staticmethod"><a href="#11-5-classmethod-与-staticmethod" class="headerlink" title="11.5　classmethod 与 staticmethod"></a>11.5　classmethod 与 staticmethod</h2><blockquote>
<p><strong>示例 11-4</strong>　比较 <code>classmethod</code> 和 <code>staticmethod</code> 的行为</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>:</span></span><br><span class="line"><span class="meta">... </span>    @classmethod</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">klassmeth</span><span class="params">(*args)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> args  ❶</span><br><span class="line"><span class="meta">... </span>    @staticmethod</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">statmeth</span><span class="params">(*args)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> args  ❷</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Demo.klassmeth()  ❸</span><br><span class="line">(&lt;class '__main__.Demo'&gt;,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Demo.klassmeth(<span class="string">'spam'</span>)</span><br><span class="line">(&lt;class '__main__.Demo'&gt;, 'spam')</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Demo.statmeth()   ❹</span><br><span class="line">()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Demo.statmeth(<span class="string">'spam'</span>)</span><br><span class="line">(<span class="string">'spam'</span>,)</span><br></pre></td></tr></table></figure>

<p>❶ <code>klassmeth</code> 返回全部位置参数。</p>
<p>❷ <code>statmeth</code> 也返回全部位置参数。</p>
<p>❸ 不管怎样调用 <code>Demo.klassmeth</code>，它的第一个参数始终是 <code>Demo</code> 类。</p>
<p>❹ <code>Demo.statmeth</code> 的行为与普通的函数一样。</p>
<p>classmethod 装饰器非常有用，但是我从未见过不得不使用 staticmethod 的情况。有些函数即使不直接处理类，也与类联系紧密，因此你会想把函数与类放在一起定义。对于这种情况，在类的前面或后面定义函数，保持二者在同一个模块中基本上就可以了。</p>
<h1 id="第-17-章-迭代器、生成器和经典协程"><a href="#第-17-章-迭代器、生成器和经典协程" class="headerlink" title="第 17 章　迭代器、生成器和经典协程"></a>第 17 章　迭代器、生成器和经典协程</h1><h2 id="17-5-为-Sentence-类实现-iter-方法"><a href="#17-5-为-Sentence-类实现-iter-方法" class="headerlink" title="17.5　为 Sentence 类实现 iter 方法"></a>17.5　为 Sentence 类实现 <strong>iter</strong> 方法</h2><h3 id="17-5-4-生成器的工作原理"><a href="#17-5-4-生成器的工作原理" class="headerlink" title="17.5.4　生成器的工作原理"></a>17.5.4　生成器的工作原理</h3><p>17.5.4　生成器的工作原理<br>只要 Python 函数的主体中有 yield 关键字，该函数就是生成器函数。调用生成器函数，返回一个生成器对象。也就是说，生成器函数是生成器工厂。</p>
<h2 id="17-11-yield-from：从子生成器中产出"><a href="#17-11-yield-from：从子生成器中产出" class="headerlink" title="17.11　yield from：从子生成器中产出"></a>17.11　yield from：从子生成器中产出</h2><p>17.11　yield from：从子生成器中产出<br>Python 3.3 新增的 yield from 表达式句法可把一个生成器的工作委托给一个子生成器。</p>
<p>引入 yield from 之前，如果一个生成器根据另一个生成器生成的值产出值，则需要使用 for 循环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">sub_gen</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">1.1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">1.2</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> i <span class="keyword">in</span> sub_gen():</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">yield</span> i</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> gen():</span><br><span class="line"><span class="meta">... </span>    print(x)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1.1</span></span><br><span class="line"><span class="number">1.2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">使用 <span class="keyword">yield</span> <span class="keyword">from</span> 可以达到相同的效果，如示例 <span class="number">17</span><span class="number">-25</span> 所示。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">17</span><span class="number">-25</span>　测试驱动 <span class="keyword">yield</span> <span class="keyword">from</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">sub_gen</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">1.1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">1.2</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="keyword">from</span> sub_gen()</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> gen():</span><br><span class="line"><span class="meta">... </span>    print(x)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1.1</span></span><br><span class="line"><span class="number">1.2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>


<p>子生成器中有 return 语句时，返回一个值，在委托生成器中，通过含有 yield from 的表达式可以捕获那个值，如示例 17-26 所示。</p>
<p>示例 17-26　yield from 获取子生成器的返回值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">sub_gen</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">1.1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">1.2</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="string">'Done!'</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    result = <span class="keyword">yield</span> <span class="keyword">from</span> sub_gen()</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'&lt;--'</span>, result)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> gen():</span><br><span class="line"><span class="meta">... </span>    print(x)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1.1</span></span><br><span class="line"><span class="number">1.2</span></span><br><span class="line">&lt;-- Done!</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>子生成器中的yield不是返回值</p>
<h1 id="第-18-章-with、match-和-else-块"><a href="#第-18-章-with、match-和-else-块" class="headerlink" title="第 18 章　with、match 和 else 块"></a>第 18 章　with、match 和 else 块</h1><p>第 18 章　with、match 和 else 块</p>
<p>本书暂时读到此章节，后续需要进阶再读，内容包含并发，元编程等<br>#TODO/未读完</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E2%9C%B0%E2%9C%B0%E2%9C%B0%E2%9C%B0%E2%9C%B0/" rel="tag"># ✰✰✰✰✰</a>
              <a href="/tags/OReilly/" rel="tag"># OReilly</a>
              <a href="/tags/python/" rel="tag"># python</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/03/01/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6/%E4%B8%80%E7%BB%9F%E6%B1%9F%E5%B1%B1%E4%B9%8B%E5%90%8E%EF%BC%9A%E5%A4%A7%E6%98%8E%E5%85%B4%E4%BA%A1%E4%B9%8B%E8%B0%9C%EF%BC%88%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E5%87%BA%E5%93%81%EF%BC%89/" rel="prev" title="微信读书/一统江山之后：大明兴亡之谜（微信读书出品）">
      <i class="fa fa-chevron-left"></i> 微信读书/一统江山之后：大明兴亡之谜（微信读书出品）
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/03/13/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6/%E8%A1%80%E9%85%AC%E5%AE%9A%E5%BE%8B%EF%BC%9A%E4%B8%AD%E5%9B%BD%E5%8E%86%E5%8F%B2%E4%B8%AD%E7%9A%84%E7%94%9F%E5%AD%98%E6%B8%B8%E6%88%8F/" rel="next" title="微信读书/血酬定律：中国历史中的生存游戏">
      微信读书/血酬定律：中国历史中的生存游戏 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-1-章-Python-数据模型"><span class="nav-number">2.</span> <span class="nav-text">第 1 章　Python 数据模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#不使用-collection-len-，而是使用-len-collection"><span class="nav-number">2.0.1.</span> <span class="nav-text">不使用 collection.len()，而是使用 len(collection)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特殊方法的名称前后两端都有双下划线。"><span class="nav-number">2.0.2.</span> <span class="nav-text">特殊方法的名称前后两端都有双下划线。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-一摞-Python-风格的纸牌"><span class="nav-number">2.1.</span> <span class="nav-text">1.2　一摞 Python 风格的纸牌</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#两个for循环"><span class="nav-number">2.1.1.</span> <span class="nav-text">两个for循环</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-特殊方法是如何使用的"><span class="nav-number">2.2.</span> <span class="nav-text">1.3　特殊方法是如何使用的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-2-字符串表示形式"><span class="nav-number">2.2.1.</span> <span class="nav-text">1.3.2　字符串表示形式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-4-集合-API"><span class="nav-number">2.2.2.</span> <span class="nav-text">1.3.4　集合 API</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-2-章-丰富的序列"><span class="nav-number">3.</span> <span class="nav-text">第 2 章　丰富的序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-内置序列类型概览"><span class="nav-number">3.1.</span> <span class="nav-text">2.2　内置序列类型概览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-列表推导式和生成器表达式"><span class="nav-number">3.2.</span> <span class="nav-text">2.3　列表推导式和生成器表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3-笛卡儿积"><span class="nav-number">3.2.1.</span> <span class="nav-text">2.3.3　笛卡儿积</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-元组不仅仅是不可变列表"><span class="nav-number">3.3.</span> <span class="nav-text">2.4　元组不仅仅是不可变列表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-1-用作记录"><span class="nav-number">3.3.1.</span> <span class="nav-text">2.4.1　用作记录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-3-列表和元组方法的比较"><span class="nav-number">3.3.2.</span> <span class="nav-text">2.4.3　列表和元组方法的比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-序列和可迭代对象拆包"><span class="nav-number">3.4.</span> <span class="nav-text">2.5　序列和可迭代对象拆包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-1-使用-获取余下的项"><span class="nav-number">3.4.1.</span> <span class="nav-text">2.5.1　使用 * 获取余下的项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-3-嵌套拆包"><span class="nav-number">3.4.2.</span> <span class="nav-text">2.5.3　嵌套拆包</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7-切片"><span class="nav-number">3.5.</span> <span class="nav-text">2.7　切片</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-1-为什么切片和区间排除最后一项"><span class="nav-number">3.5.1.</span> <span class="nav-text">2.7.1　为什么切片和区间排除最后一项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-4-为切片赋值"><span class="nav-number">3.5.2.</span> <span class="nav-text">2.7.4　为切片赋值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-8-使用-和-处理序列"><span class="nav-number">3.6.</span> <span class="nav-text">2.8　使用 + 和 * 处理序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-9-list-sort-与内置函数-sorted"><span class="nav-number">3.7.</span> <span class="nav-text">2.9　list.sort 与内置函数 sorted</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#list-sort-方法就地排序列表，即不创建副本。返回值为-None"><span class="nav-number">3.7.1.</span> <span class="nav-text">list.sort 方法就地排序列表，即不创建副本。返回值为 None</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内置函数-sorted-返回创建的新列表"><span class="nav-number">3.7.2.</span> <span class="nav-text">内置函数 sorted 返回创建的新列表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-10-当列表不适用时"><span class="nav-number">3.8.</span> <span class="nav-text">2.10　当列表不适用时</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#经常需要在列表的两端添加和删除项，使用-deque（double-ended-queue，双端队列）"><span class="nav-number">3.8.1.</span> <span class="nav-text">经常需要在列表的两端添加和删除项，使用 deque（double-ended queue，双端队列）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#经常检查集合中是否存在某一项–使用set-类型"><span class="nav-number">3.8.2.</span> <span class="nav-text">经常检查集合中是否存在某一项–使用set 类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-10-1-数组"><span class="nav-number">3.8.3.</span> <span class="nav-text">2.10.1　数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#array-array-–-列表只包含数值"><span class="nav-number">3.9.</span> <span class="nav-text">array.array – 列表只包含数值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-10-3-NumPy"><span class="nav-number">3.9.1.</span> <span class="nav-text">2.10.3　NumPy</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-11-本章小结"><span class="nav-number">3.10.</span> <span class="nav-text">2.11　本章小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-12-延伸阅读"><span class="nav-number">3.11.</span> <span class="nav-text">2.12　延伸阅读</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-3-章-字典和集合"><span class="nav-number">4.</span> <span class="nav-text">第 3 章　字典和集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-本章新增内容"><span class="nav-number">4.1.</span> <span class="nav-text">3.1　本章新增内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-字典的现代句法"><span class="nav-number">4.2.</span> <span class="nav-text">3.2　字典的现代句法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-字典推导式"><span class="nav-number">4.2.1.</span> <span class="nav-text">3.2.1　字典推导式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-8-字典视图"><span class="nav-number">4.3.</span> <span class="nav-text">3.8　字典视图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-10-集合论"><span class="nav-number">4.4.</span> <span class="nav-text">3.10　集合论</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-5-章-数据类构建器"><span class="nav-number">5.</span> <span class="nav-text">第 5 章　数据类构建器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-数据类构建器概述"><span class="nav-number">5.1.</span> <span class="nav-text">5.2　数据类构建器概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#namedtuple"><span class="nav-number">5.1.1.</span> <span class="nav-text">namedtuple</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-6-章-对象引用、可变性和垃圾回收"><span class="nav-number">6.</span> <span class="nav-text">第 6 章　对象引用、可变性和垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-6-del-和垃圾回收"><span class="nav-number">6.1.</span> <span class="nav-text">6.6　del 和垃圾回收</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-7-章-函数是一等对象"><span class="nav-number">7.</span> <span class="nav-text">第 7 章　函数是一等对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-高阶函数"><span class="nav-number">7.1.</span> <span class="nav-text">7.3　高阶函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#map、filter-和-reduce-的现代替代品"><span class="nav-number">7.1.1.</span> <span class="nav-text">map、filter 和 reduce 的现代替代品</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5-9-种可调用对象"><span class="nav-number">7.2.</span> <span class="nav-text">7.5　9 种可调用对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-10-延伸阅读"><span class="nav-number">7.3.</span> <span class="nav-text">7.10　延伸阅读</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-10-章-使用一等函数实现设计模式"><span class="nav-number">8.</span> <span class="nav-text">第 10 章　使用一等函数实现设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-2-案例分析：重构策略模式"><span class="nav-number">8.1.</span> <span class="nav-text">10.2　案例分析：重构策略模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-1-经典的策略模式"><span class="nav-number">8.1.1.</span> <span class="nav-text">10.2.1　经典的策略模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-11-章-符合-Python-风格的对象"><span class="nav-number">9.</span> <span class="nav-text">第 11 章　符合 Python 风格的对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#11-5-classmethod-与-staticmethod"><span class="nav-number">9.1.</span> <span class="nav-text">11.5　classmethod 与 staticmethod</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-17-章-迭代器、生成器和经典协程"><span class="nav-number">10.</span> <span class="nav-text">第 17 章　迭代器、生成器和经典协程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#17-5-为-Sentence-类实现-iter-方法"><span class="nav-number">10.1.</span> <span class="nav-text">17.5　为 Sentence 类实现 iter 方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#17-5-4-生成器的工作原理"><span class="nav-number">10.1.1.</span> <span class="nav-text">17.5.4　生成器的工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-11-yield-from：从子生成器中产出"><span class="nav-number">10.2.</span> <span class="nav-text">17.11　yield from：从子生成器中产出</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-18-章-with、match-和-else-块"><span class="nav-number">11.</span> <span class="nav-text">第 18 章　with、match 和 else 块</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="郭富城"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">郭富城</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">236</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">111</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/gxianch" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gxianch" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/%E5%8F%91%E9%82%AE%E4%BB%B6%E8%87%B3:g.xian.ch@gmail.com" title="E-Mail → 发邮件至:g.xian.ch@gmail.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://zh.singlelogin.re/" title="https:&#x2F;&#x2F;zh.singlelogin.re&#x2F;" rel="noopener" target="_blank">ZLibrary</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.banshujiang.cn/" title="http:&#x2F;&#x2F;www.banshujiang.cn&#x2F;" rel="noopener" target="_blank">banshujiang</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.packtpub.com/tech" title="https:&#x2F;&#x2F;www.packtpub.com&#x2F;tech" rel="noopener" target="_blank">packtpub</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.manning.com/" title="https:&#x2F;&#x2F;www.manning.com&#x2F;" rel="noopener" target="_blank">manning</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://coolshell.cn/" title="https:&#x2F;&#x2F;coolshell.cn&#x2F;" rel="noopener" target="_blank">coolshell</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">郭富城</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
