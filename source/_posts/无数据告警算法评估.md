---
title: 无数据告警算法评估
date: 2023-09-09 20:09:30
categories: [算法]
toc: true
mathjax: true
top: 98
tags:
  - bitmap
---


## 实时计算无数据告警的逻辑
### 基线数据定义：
基线数据是一组带时分的时序数据，时分是根据配置对24小时进行分割得到，比如配置1分钟内没数据告警，则24小时按1分钟进行分割，则分割成00:01, 00:02…的时序数据,总共1440条记录，1440条表示每个1分钟窗口内有一条数据。配置5分钟内没数据则告警，则按5分钟进行分割，则分割成00:05, 00:10…的时序数据,每个时间窗口内有且仅有一条数据。每个任务对应一组基线数据。

### 集合运算
并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。
![jpg](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/26/16b93c585c6a1b84~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)

交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。
![jpg](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/26/16b93ca4118bf2d7~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)
差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。
![jpg](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/26/16b93deea973de09~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)


### 告警实现逻辑:
定义基线数据后，基线数据作为一个流和原数据流进行合并，同一个任务的基线数据的key和流数据的key是相同的，计算时间窗口内基线数据的key作为一个集合A，流数据的key作为一个集合B，两个集合取差集，元素key1存在A中，且key1不存在于B中, 则key1就是作为告警发出的数据。

### 差集算法：
为了模拟无数据告警的差集算法，模拟基线数据作为集合A，生成一百万条key，模拟流数据作为集合B，生成999000条key，集合A/B差集就是输出的告警key。

##### 嵌套两个for循环遍历集合
嵌套两个for循环来遍历这两个集合，时间复杂度是O(n^2)
```java
private static void testFor() {  
    System.err.println("-------------testFor-------------");  
    List<String> listA = new ArrayList<>();  
    for(int i=0;i<OneMillion;i++){  
        String key1="ip(192.168.199.10"+i+")#port("+i+")#service_name(orcl)#time(23:30:00)"+i;  
        listA.add(key1);  
    }  
    List<String> listB =   createRandomList(listA,999000);  
    Date date = new Date();  
    listA.removeAll(listB);  
    Date date1 = new Date();  
    System.out.println("//testFor:"+(date1.getTime()-date.getTime())/1000+"秒");  
}
//testFor: 30分钟内未出结果
```

##### 用Hash表将嵌套的for循环改为单个的for循环
借助Hash表的快速访问能力来将嵌套的for循环改为单个的for循环，时间复杂度是O(n),代码示例及耗时
```JAVA
private static void testHashSet() {  
    System.err.println("-------------testHashSet-------------");  
    List<String> listA = new ArrayList<>();  
    for(int i=0;i<OneMillion;i++){  
        String key1="ip(192.168.199.10"+i+")#port("+i+")#service_name(orcl)#time(23:30:00)"+i;  
        listA.add(key1);  
    }  
    List<String> listB =   createRandomList(listA,999000);  
    Date date = new Date();  
    listA.removeAll(new HashSet(listB));  
    Date date1 = new Date();  
    System.out.println("//testHashSet:"+(double)(date1.getTime()-date.getTime())/1000+"秒");  

}
//testHashSet:0.476秒
```



##### BitmapHash结构
key通过Math.abs(key.hashCode())方式转整数进行位图计算，时间复杂度是O(1)，耗时明显减少，但是hash有碰撞概率，有概率出现误告警
```java
private static void testBitmapHashCode() {  
    System.err.println("-------------testBitmapHashCode-------------");  
    BitSet bitmap = new BitSet();  
    for(int i=0;i<OneMillion;i++){  
        String key1="ip(192.168.199.10"+i+")#port("+i+")#service_name(orcl)#time(23:30:00)"+i;  
        bitmap.set(Math.abs(key1.hashCode()));  //9995594 有重复  
    }  
    BitSet bitmap1 = new BitSet();  
    for(int i=0;i<999000;i++){  
        String key1="ip(192.168.199.10"+i+")#port("+i+")#service_name(orcl)#time(23:30:00)"+i;  
        bitmap1.set(Math.abs(key1.hashCode()));  
    }  
    Date date = new Date();  
    System.out.println(bitmap.stream().count());  
    bitmap.andNot(bitmap1);  
    Date date1 = new Date();  
    System.out.println("testBitmapHashCode:"+(double)(date1.getTime()-date.getTime())/1000+"秒");  
}
//testBitmapHashCode:0.243秒
```

##### RoaringBitmap结构
相比Bitmap，占用空间更小，计算更快 ，但是缺点同BitmapHash结构，字符串hash转整数的过程出现碰撞，会出现误告警
```java
private static void testRoaringBitmapHashCode() {  
    System.err.println("-------------testRoaringBitmapHashCode-------------");  
    RoaringBitmap bitmap = new RoaringBitmap();  
    for(int i=0;i<OneMillion;i++){  
        String key1="ip(192.168.199.10"+i+")#port("+i+")#service_name(orcl)#time(23:30:00)"+i;  
        bitmap.add(Math.abs(key1.hashCode()));  //9995594 有重复  
    }  
    RoaringBitmap bitmap1 = new RoaringBitmap();  
    for(int i=0;i<999000;i++){  
        String key1="ip(192.168.199.10"+i+")#port("+i+")#service_name(orcl)#time(23:30:00)"+i;  
        bitmap1.add(Math.abs(key1.hashCode()));  
    }  
    Date date = new Date();  
    bitmap.andNot(bitmap1);  
    Date date1 = new Date();  
    System.out.println("testRoaringBitmapHashCode:"+(double)(date1.getTime()-date.getTime())/1000+"秒");  
}
//testRoaringBitmapHashCode:0.048秒
```


### 总结：
上述差集方式分两类
第一类是直接获取key取差集，表现最好的是用Hash表将嵌套的for循环改为单个的for循环，时间复杂度为O(n),一百万条key时间耗时 0.476秒。
第二类是将key进行hash转换后再取差集，表现最好的是采用RoaringBitmap结构，时间复杂度是O(1)，耗时0.048秒，相比第一类最优耗时 0.476秒，时间减少一个数量级，但是RoaringBitmap结构的缺点是要求必须是整数(需要将字符串hash成整数后代入RoaringBitmap结构进行位图计算)，在字符串hash转整数的过程中有一定概率出现hash碰撞，导致误告警，而且求差集的数据量越大，出现hash碰撞的次数越多，误告警数据越多。
因此需要根据使用情况进行选择，如果允许出现一定的误告警，建议采用Bitmap位图结构。