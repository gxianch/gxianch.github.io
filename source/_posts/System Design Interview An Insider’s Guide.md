---
title: System Design Interview An Insider’s Guide
author: Alex Xu
date: 2024-10-08
time: 02:38
toc: true
mathjax: true
top: 98
categories:
  - 编程
tags:
  - ✰✰✰✰✰✰
  - SystemDesign
  - TODO
---




简介
clearview阅读
超多图片，图解系统设计，就凭这么多图值得5星

摘要
这篇文章主要介绍了系统设计面试中常见的题目和相应的解决方案，作者以实际案例和图表的形式详细讲解了如何设计一个优秀的系统，包括但不限于：限速器、一致性哈希、键值存储、唯一ID生成器、URL缩短器、网络爬虫、通知系统、新闻提要系统、聊天系统、搜索自动完成系统、YouTube、谷歌云盘等。文章还介绍了系统设计面试的通用框架以及一些重要的技术细节。
<!-- more -->
#### 前言

本前言简要介绍了系统设计面试的挑战和重要性，指出其开放式、无标准答案的特点，并强调了本书的目标是帮助读者掌握应对这类面试的技巧。

# 第一章：从零到百万用户(SCALE FROM ZERO TO MILLIONS OF USERS)

本章从构建单用户系统开始，逐步扩展到支持百万用户，涵盖了许多系统设计面试中的关键技术，包括：

## **单服务器设置:** 介绍了最基础的系统架构，所有组件都运行在同一服务器上。

![[attachments/2e9fdcc6ac84c181b05f01beb164917c_MD5.jpeg]]
> [!hint]
> 1. Users access websites through domain names, such as api.mysite.com. Usually, the Domain Name System (DNS) is a paid service provided by 3rd parties and not hosted by our servers.
> 2. Internet Protocol (IP) address is returned to the browser or mobile app. In the example, IP address 15.125.23.214 is returned.
> 3. Once the IP address is obtained, Hypertext Transfer Protocol (HTTP) [1] requests are sent directly to your web server.
> 4. The web server returns HTML pages or JSON response for rendering.


## **数据库:** 随着用户增加，需要单独的数据库服务

![[attachments/cd518e0692ef7613d948df2e82a2d5d6_MD5.jpeg]]

## 负载均衡(Load balancer)

使用负载均衡器将流量分发到多台 Web 服务器，提高系统吞吐量和可用性。

![[attachments/977041e957628298621bf2f38316d13a_MD5.jpeg]]

## 数据库副本 Database replication
一个主数据库和多个从数据库，使用主从复制来提高数据库的可用性和读取性能。

![[attachments/6c3a942eec872382ba9c016aa0dbac09_MD5.jpeg]]
> [!tip]
> Advantages of database replication:
> 数据库副本的优势:
> 
> • Better performance: In the master-slave model, all writes and updates happen in master nodes; whereas, read operations are distributed across slave nodes. This model improves performance because it allows more queries to be processed in parallel.
> • 更好的性能: 在一个主从架构，所有的写和更新发生在主库，读操作分散在从库节点，因为允许并行查询所以性能更好
> 
> • Reliability: If one of your database servers is destroyed by a natural disaster, such as a typhoon or an earthquake, data is still preserved. You do not need to worry about data loss because data is replicated across multiple locations.
> • 更可靠：如果一个数据库挂了，不用担心数据丢失，数据被复制到多个地方
> 
> • High availability: By replicating data across different locations, your website remains in
> operation even if a database is offline as you can access data stored in another database server.
> • 高可用：
> 

> [!hint]
> 
图1-5架构可以解决以下问题
• If only one slave database is available and it goes offline, read operations will be directed to the master database temporarily. As soon as the issue is found, a new slave database will replace the old one. In case multiple slave databases are available, read operations are redirected to other healthy slave databases. A new database server will replace the old one.
• 如果只有一个从库可用并且离线了，读操作直接临时读主库，如果有多个从库，读操作可以直接转到其他正常的从库
> 
• If the master database goes offline, a slave database will be promoted to be the new master. All the database operations will be temporarily executed on the new master database. A new slave database will replace the old one for data replication immediately.
> 如果主库离线，一个从库会被当选为新的主库

## 负载均衡加数据库副本
![[attachments/65fb3d4353f0190419d6ac5c4fb8451a_MD5.jpeg]]


## 缓存层Cache tier

使用缓存来存储常用的数据，减少数据库负载并提高响应速度。

> [!attention] 
> 使用缓存的注意事项
> 
• 决定何时使用缓存。当数据被频繁读取但不频繁修改时，请考虑使用缓存。由于缓存数据存储在易失性存储器中，因此缓存服务器不适合持久保存数据。例如，如果缓存服务器重新启动，内存中的所有数据都会丢失。因此，重要数据应保存在持久数据存储中。
>
• 过期策略。实施过期策略是一种很好的做法。缓存数据一旦过期，就会从缓存中删除。如果没有过期策略，缓存数据将永久存储在内存中。建议不要将过期日期设置得太短，因为这会导致系统过于频繁地从数据库重新加载数据。同时，建议不要将过期日期设置得太长，因为数据可能会变得陈旧。
>
• 一致性：这涉及保持数据存储和缓存同步。不一致可能发生，因为数据存储和缓存上的数据修改操作不在单个事务中。在跨多个区域扩展时，保持数据存储和缓存之间的一致性具有挑战性。
>
• 避免单点故障：单个缓存服务器代表潜在的单点故障 (SPOF)，因此，建议在不同数据中心使用多个缓存服务器以避免 SPOF。另一种推荐的方法是按一定百分比过度配置所需的内存。随着内存使用量的增加，这可以提供缓冲。
>
• 驱逐策略：一旦缓存已满，任何向缓存添加项目的请求都可能导致现有项目被删除。这称为缓存驱逐。最近最少使用 (LRU) 是最流行的缓存驱逐策略。可以采用其他驱逐策略，例如最不常用 (LFU) 或先进先出 (FIFO)，以满足不同的用例。

## CDN (Content delivery network)
> [!hint] 
内容分发网络（CDN）：将静态内容（JavaScript、CSS、图片、视频等）托管到 CDN，降低延迟并提高性能。

![[attachments/730aff25ea222f653a0323e6636b94f4_MD5.jpeg]]




![[attachments/8a6eeb14ce489dbe27e09dd59e093a39_MD5.jpeg]]
> [!hint]
> 1. Static assets (JS, CSS, images, etc.,) are no longer served by web servers. They are fetched from the CDN for better performance.
> 2. The database load is lightened by caching data.


## 无状态网络层 Stateless web tier

现在是时候考虑水平扩展 Web 层了。为此，我们需要将状态（例如用户会话数据）移出 Web 层。一种好的做法是将会话数据存储在持久存储中，例如关系数据库或 NoSQL。集群中的每个 Web 服务器都可以从数据库访问状态数据。这称为无状态 Web 层

### 有状态架构 Stateful architecture

有状态服务器和无状态服务器有一些关键区别。有状态服务器会记住从一个请求到下一个请求的客户端数据（状态）。无状态服务器不保留任何状态信息。

![[attachments/2b67c8e541ff461d6404110a08cf2f1d_MD5.jpeg]]


### 无状态架构Stateless architecture


![[attachments/0a165470827d69a72e5a5475902f4e36_MD5.jpeg]]

> [!hint]
> State data is stored in a shared data store and kept out of web servers

更新设计后的无状态架构
![[attachments/4bdebed5dda326b04ddda5034219b8f3_MD5.jpeg]]


> [!hint]
> 将会话数据移出 Web 层，并将其存储在持久数据存储中。共享数据存储可以是关系数据库、Memcached/Redis、NoSQL 等。选择 NoSQL 数据存储是因为它易于扩展。自动扩展意味着根据流量负载自动添加或删除 Web 服务器。将状态数据从 Web 服务器中删除后，通过根据流量负载添加或删除服务器，可以轻松实现 Web 层的自动扩展。

## 多数据中心Data centers
![[attachments/3543a1cb53e149a07dad8f397ab470fc_MD5.jpeg]]



> [!hint]
> 上图显示具有两个数据中心的示例设置。在正常运行中，用户通过 geoDNS 路由（也称为地理路由）到最近的数据中心，在美国东部的流量分割为 x%，在美国西部的流量分割为 (100 – x)%。geoDNS 是一种 DNS 服务，允许根据用户的位置将域名解析为 IP 地址。

当一个数据中心故障的时候，所有流量路由到正常的数据中心
![[attachments/3a6822cc1054a15629da43217595582d_MD5.jpeg]]

> [!hint]
> 要实现多数据中心设置，必须解决几个技术挑战：
• 流量重定向：需要有效的工具将流量引导到正确的数据中心。GeoDNS 可用于根据用户所在的位置将流量引导到最近的数据中心。
• 数据同步：来自不同地区的用户可以使用不同的本地数据库或缓存。在故障转移情况下，流量可能会被路由到数据不可用的数据中心。一种常见的策略是跨多个数据中心复制数据。
• 测试和部署：对于多数据中心设置，在不同位置测试您的网站/应用程序非常重要。自动部署工具对于在所有数据中心保持服务一致性至关重要 。
为了进一步扩展我们的系统，我们需要解耦系统的不同组件，以便可以独立扩展它们。消息队列是许多现实世界的分布式系统用来解决这个问题的关键策略。

## 消息队列 Message queue

## 日志，指标，自动化 Logging, metrics, automation

对于运行在几台服务器上的小型网站，日志记录、指标和自动化支持是很好的做法，但不是必需的。但是，现在您的网站已经发展到为大型企业提供服务，投资这些工具是必不可少的。



![[attachments/be25376f2f164d6eb82d611ea64df005_MD5.jpeg]]

> [!hint]
> 1. 设计中包含一个消息队列，有助于使系统更加松散耦合和故障恢复。
> 2. 包含日志记录、监控、指标和自动化工具。

## 数据库扩展 Database scaling
随着数据增加需要扩展数据库了，两种扩展方式水平扩展和垂直扩展
![[attachments/4c31cbba0f2ed990e5f485ea56b7d82d_MD5.jpeg]]
水平扩展也是分片

![[attachments/d8f7a29f3ba465f11ec768a51fb38594_MD5.jpeg]]
> [!hint]
> 显示了分片数据库的示例。用户数据根据用户 ID 分配给数据库服务器。每次访问数据时，都会使用哈希函数来查找相应的分片。在我们的示例中，user_id % 4 用作哈希函数。如果结果等于 0，则使用分片 0 来存储和获取数据。如果结果等于 1，则使用分片 1。同样的逻辑适用于其他分片。
![[attachments/c982b8e2b3b9deed40084cacf5a1f7bd_MD5.jpeg]]



> [!Important]
> 实施分片策略时要考虑的最重要因素是分片键的选择。分片键（称为分区键）Sharding key (known as a partition key) 由一个或多个确定数据分布方式的列组成。如图 1-22 所示，“user_id”是分片键。分片键允许您通过将数据库查询路由到正确的数据库来有效地检索和修改数据。选择分片键时，最重要的标准之一是选择可以均匀分布数据的键。
> 
> 分片是一种很好的数据库扩展技术，但它远非完美的解决方案。它给系统带来了复杂性和新挑战：
> 
> 重新分片数据(Resharding data)：当 1) 由于快速增长，单个分片无法再容纳更多数据时，需要重新分片数据。2) 由于数据分布不均匀，某些分片可能比其他分片更快地经历分片耗尽。当分片耗尽时，需要更新分片功能并移动数据。一致性哈希（将在第 5 章中讨论）是解决此问题的常用技术。
> 
名人问题(Celebrity problem)：这也称为热点键问题。对特定分片的过度访问可能会导致服务器过载。想象一下 Katy Perry、Justin Bieber 和 Lady Gaga 的数据都位于同一个分片上。对于社交应用程序，该分片将因读取操作而不堪重负。为了解决这个问题，我们可能需要为每个名人分配一个分片。每个分片甚至可能需要进一步分区。
> 
连接和反规范化(Join and de-normalization)：一旦数据库在多个服务器上分片，就很难跨数据库分片执行连接操作。一种常见的解决方法是反规范化数据库，以便可以在单个表中执行查询。

## 总结

扩展系统是一个迭代过程。迭代我们在本章中学到的知识可以让我们走得更远。需要更多的微调和新策略来扩展数百万用户。例如，您可能需要优化系统并将系统解耦为更小的服务。本章中学到的所有技术都应该为应对新挑战提供良好的基础。为了结束本章，我们总结了我们如何扩展系统以支持数百万用户：
• 保持 Web 层无状态 Keep web tier stateless
• 在每个层构建冗余 Build redundancy at every tier
• 尽可能多地缓存数据 Cache data as much as you can
• 支持多个数据中心 Support multiple data centers
• 在 CDN 中托管静态资产 Host static assets in CDN
• 通过分片扩展数据层 Scale your data tier by sharding
• 将层拆分为单个服务 Split tiers into individual services
• 监控系统并使用自动化工具 Monitor your system and use automation tools


# 第二章：粗略估算

本章介绍了系统设计面试中常用的粗略估算技巧，帮助读者评估系统容量和性能需求，主要内容包括：

## **2 的幂次方:** 回顾了数据容量单位的计算基础，强调了理解 2 的幂次方在分布式系统中的重要性。
![[attachments/7e39bee1c5c578525f4a99b5588cdeff_MD5.jpeg]]
## **程序员应知的延迟数据:** 列举了典型计算机操作的延迟时间，帮助读者理解不同操作的快慢程度，并指导设计决策。
![[attachments/724ea5183e862d3ad15f6b8dcd853ed8_MD5.jpeg]]


![[attachments/73c6110574da10a9be7528a63957682d_MD5.jpeg]]
> [!conclusions]
> • Memory is fast but the disk is slow.  
• Avoid disk seeks if possible.  
• Simple compression algorithms are fast.
• Compress data before sending it over the internet if possible.  
• Data centers are usually in different regions, and it takes time to send data between them.


## **可用性指标:** 介绍了高可用性的概念和衡量方法，解释了服务级别协议 (SLA) 和 “9” 的含义。
![[attachments/da813af589dbed85623472090d3d94eb_MD5.jpeg]]

- **实例：估算 Twitter 的 QPS 和存储需求:** 通过一个具体的例子，展示了如何运用粗略估算来评估系统的关键指标。
- **技巧:** 分享了进行粗略估算的实用技巧，包括舍入、近似、写下假设、标注单位和常见估算问题等。

# 第三章：系统设计面试框架

本章提出了一个有效的系统设计面试四步法，帮助读者在面试中展现结构化的思考过程和解决问题的能力：

- **第一步 - 理解问题并确定设计范围:** 强调了在回答问题前深入理解需求的重要性，并鼓励主动提问以澄清模糊点。
- **第二步 - 提出高层设计并获得认同:** 建议从高层架构开始设计，并与面试官沟通以确保方案的可行性。
- **第三步 - 深入设计细节:** 逐步细化设计方案，包括数据模型、算法选择、技术选型等。
- **第四步 - 总结:** 简要回顾设计方案，并回答面试官的最终问题。

# 第四章：设计速率限制器

## 如何设计一个限速器？

#### 在设计限速器时，需要考虑以下因素：

- **限速规则：** 基于哪些因素进行限速，例如 IP 地址、用户 ID 或 API 密钥。
- **算法：** 使用哪种限速算法，例如令牌桶、漏桶、固定窗口计数器或滑动窗口计数器。
- **实现方式：** 在客户端实现、服务器端实现或使用第三方网关。
- **分布式环境：** 如何在分布式环境中实现限速。

#### **常见算法：**

#####  令牌桶（Token bucket ）：
定期向桶中添加令牌，每个请求消耗一个令牌，如果桶中没有足够的令牌，则拒绝请求。
![[attachments/fd4524e99716b3e7c045782239b46500_MD5.jpeg]]
![[attachments/6c6f1456065c75d314e77c4d858e1690_MD5.jpeg]]
 
![[attachments/972178ac87f0c826136e0c3b726bfdc1_MD5.jpeg]]

> [!hint]
> 令牌消耗、补充和速率限制逻辑的工作原理。在此示例中，令牌桶大小为 4，补充速率为每分钟 4 次。

##### **漏桶（Leaking bucket ）：** 
请求以恒定速率进入桶中，如果桶已满，则丢弃请求。
漏桶算法与令牌桶类似，不同之处在于请求以固定速率处理。它通常使用先进先出 (FIFO) 队列实现
![[attachments/be2098759c8424cfe41be9c6d31772d0_MD5.jpeg]]
> [!hint]
> • 当请求到达时，系统会检查队列是否已满。如果队列未满，则将请求添加到队列中。
• 否则，将丢弃请求。
• 请求会从队列中拉出并定期处理。


> [!hint]
> Leaking bucket algorithm takes the following two parameters:
• Bucket size: it is equal to the queue size. The queue holds the requests to be processed at a fixed rate.
• Outflow rate: it defines how many requests can be processed at a fixed rate, usually in seconds.


> [!hint]
> 优点：
• 考虑到队列大小有限，内存效率高。
• 请求以固定速率处理，因此适用于需要稳定流出速率的用例。
缺点：
• 突发流量会用旧请求填满队列，如果未及时处理，最近的请求将受到速率限制。
• 算法中有两个参数。可能不容易正确调整它们。

##### **固定窗口计数器（Fixed window counter ）：** 
将时间划分为固定大小的窗口，每个窗口有一个计数器，当计数器达到阈值时，拒绝请求。

> [!hint]
>    固定窗口计数器算法的工作原理如下：
> - 该算法将时间线划分为固定大小的时间窗口，并为每个窗口分配一个计数器。
>- 每个请求会使计数器增加1。
>- 一旦计数器达到预定义的阈值，在新的时间窗口开始之前，新的请求将被丢弃。

![[attachments/f0fa51d010ef7ab528d8f99c62bf4e0b_MD5.jpeg]]
> [!hint]
> 时间单位为 1 秒，系统每秒最多允许 3 个请求。在每秒窗口内，如果收到超过 3 个请求，则丢弃多余的请求

该算法的一个主要问题是，时间窗口边缘的流量爆发可能导致超过允许配额的请求数。考虑以下情况：

![[attachments/9aa46218122aada7191779ed33f0f0e6_MD5.jpeg]]
> [!hint]
> 2:00:30 and 2:01:30这一分钟有10个请求，且在限速器允许范围内，超过了每分钟5个请求的限速



##### 滑动窗口日志算法 Sliding window log 

如前所述，固定窗口计数器算法有一个主要问题：它允许更多请求在窗口边缘通过。滑动窗口日志算法解决了这个问题。它的工作原理如下：
• 该算法跟踪请求时间戳。时间戳数据通常保存在缓存中，例如 Redis 的排序集。
• 当新请求进入时，删除所有过时的时间戳。过时的时间戳定义为早于当前时间窗口开始的时间戳。
• 将新请求的时间戳添加到日志中。
• 如果日志大小等于或低于允许的计数，则接受请求。否则，请求将被拒绝。

示例：只允许2个请求每分钟
![[attachments/31d62748c72cc86d5cdc3e059bc480da_MD5.jpeg]]


#####  滑动窗口计数器(Sliding window counter)：
 结合固定窗口计数器和滑动窗口日志，更精确地控制速率。
![[attachments/b91ef09fd4edd27d8305ac059e9f8e40_MD5.jpeg]]
假设限流器每分钟最多允许 7 个请求，上一分钟有 5 个请求，当前分钟有 3 个请求。对于当前分钟到达 30% 位置的新请求，滚动窗口中的请求数使用以下公式计算：
• 当前窗口中的请求数 + 前一个窗口中的请求数 * 滚动窗口与前一个窗口的重叠百分比
• 使用此公式，我们得到 3 + 5 * 0.7% = 6.5 个请求。根据用例，该数字可以向上或向下舍入。在我们的示例中，它向下舍入为 6。
由于速率限制器允许每分钟最多 7 个请求，因此当前请求可以通过。但是，在收到另一个请求后将达到限制。


## 高级架构
速率限制算法的基本思想很简单。在高级层面上，我们需要一个计数器来跟踪从同一用户、IP 地址等发送了多少个请求。如果计数器大于限制，则不允许该请求。
我们应该将计数器存储在哪里？由于磁盘访问速度慢，使用数据库不是一个好主意。选择内存缓存是因为它速度快并且支持基于时间的过期策略。例如，Redis [11] 是实现速率限制的流行选项。它是一个内存存储，提供两个命令：INCR 和 EXPIRE。
• INCR：它将存储的计数器增加 1。
• EXPIRE：它为计数器设置超时。如果超时到期，计数器将自动删除。


![[attachments/c9ae18003c87eaa5dae340e891383983_MD5.jpeg]]


## 速率限制器请求头

客户端如何知道它是否受到限制？客户端如何知道在受到限制之前允许的剩余请求数？答案在于 HTTP 响应请求头。速率限制器向客户端返回以下 HTTP 请求头：

X-Ratelimit-Remaining：窗口内允许的剩余请求数。
X-Ratelimit-Limit：它表示客户端在每个时间窗口内可以进行多少次调用。
X-Ratelimit-Retry-After：等待多少秒才能再次发出请求而不会受到限制。

当用户发送了太多请求时，会向客户端返回 429 请求过多错误和 X-Ratelimit-Retry-After 请求头。



# 第五章：设计一致性哈希CONSISTENT HASHING




## 重新hash问题rehashing problem
重新哈希问题：当服务器数量变化时，使用简单的模运算进行哈希会导致大量数据需要重新分配

当有四个桶时, key根据hash%4得出的结果放哪个桶下

![[attachments/2c68b1ff54c7230c3840b20cb7ed5501_MD5.jpeg]]
当一个桶掉线时，会移到大量的key到其它服务
![[attachments/342ca26d9ded8a9eca2e41285e5eede6_MD5.jpeg]]
如图 5-2 所示，大多数键都会被重新分配，而不仅仅是最初存储在离线服务器（服务器 1）中的键。这意味着当服务器 1 离线时，大多数缓存客户端将连接到错误的服务器来获取数据。这会导致缓存未命中风暴。一致性哈希是一种有效的缓解此问题的技术。
> [!tip]
引自维基百科：“一致性哈希是一种特殊的哈希，当哈希表调整大小并使用一致性哈希时，平均只需要重新映射 k/n 个键，其中 k 是键的数量，n 是槽的数量。相比之下，在大多数传统哈希表中，数组槽数量的变化会导致几乎所有键都需要重新映射 ”。

## 一致性哈希

- 哈希空间和哈希环：将服务器和键映射到一个虚拟的哈希环上。
- 添加/删除服务器：当服务器添加或删除时，只有一小部分键需要重新分配。 
- 虚拟节点：使用虚拟节点来解决数据分布不均匀的问题。
### 哈希服务器Hash servers
使用相同的哈希函数 f，我们根据服务器 IP 或名称将服务器映射到环上。图 5-5 显示了 4 个服务器映射到哈希环上。
![[attachments/c930b832611be149c0ba141b8e898ea5_MD5.jpeg]]


### 哈希键 Hash keys
值得一提的是，这里使用的哈希函数与“重新哈希问题”中的哈希函数不同，并且没有模运算。如图 5-6 所示，4 个缓存键（key0、key1、key2 和 key3）被哈希到哈希环上
![[attachments/b3a463f3326e948ce9e20056c9651fa3_MD5.jpeg]]

### 服务器查找 Server lookup
为了确定密钥存储在哪个服务器上，我们从环上的密钥位置开始​​顺时针查找，直到找到服务器。图 5-7 解释了这个过程。顺时针方向，key0 存储在服务器 0 上；key1 存储在服务器 1 上；key2 存储在服务器 2 上，key3 存储在服务器 3 上。
![[attachments/7d7d1d8c9c23d4e400ed0fd7054fbed2_MD5.jpeg]]


### 添加一个服务器 Add a server
使用上面描述的逻辑，添加新服务器只需要重新分配一小部分密钥。
在图 5-8 中，添加新服务器 4 后，只需要重新分配 key0。k1、k2 和 k3 仍保留在同一台服务器上。让我们仔细看看这个逻辑。在添加服务器 4 之前，key0 存储在服务器 0 上。现在，key0 将存储在服务器 4 上，因为服务器 4 是它从 key0 在环上的位置顺时针方向遇到的第一个服务器。其他密钥不会根据一致性哈希算法重新分配。
![[attachments/c8a326593728437aba81eb5bef2530fd_MD5.jpeg]]



### 删除一个服务器 Remove a server
删除服务器时，只有一小部分密钥需要使用一致性哈希重新分配。在图 5-9 中，删除服务器 1 时，只有密钥 1 必须重新映射到服务器 2。其余密钥不受影响。
![[attachments/83187652de07d9474a2ee95501fda19a_MD5.jpeg]]

### 基本方法中的两个问题
一致性哈希算法由麻省理工学院的 Karger 等人提出 [1]。基本步骤如下：
• 使用均匀分布的哈希函数将服务器和密钥映射到环上。
• 要找出密钥映射到哪个服务器，请从密钥位置顺时针移动，直到找到环上的第一个服务器。
这种方法存在两个问题。首先，考虑到可以添加或删除服务器，不可能为所有服务器保持环上的分区大小相同。分区是相邻服务器之间的哈希空间。分配给每个服务器的环上的分区大小可能非常小或相当大。在图 5-10 中，如果删除了 s1，则 s2 的分区（用双向箭头突出显示）是 s0 和 s3 分区的两倍。
![[attachments/ef22712536a7b5faff8acb8804de7aa3_MD5.jpeg]]

其次，环上的密钥分布也可能不均匀。例如，如果服务器映射到图 5-11 中列出的位置，则大多数密钥存储在服务器 2 上。但是，服务器 1 和服务器 3 没有数据。
![[attachments/cf04532fd45f3751abce785b5307e100_MD5.jpeg]]



### 虚拟节点 Virtual nodes
虚拟节点指的是真实节点，每个服务器由环上的多个虚拟节点表示。在图 5-12 中，服务器 0 和服务器 1 都有 3 个虚拟节点。3 是任意选择的；在实际系统中，虚拟节点的数量要大得多。我们不使用 s0，而是使用 s0_0、s0_1 和 s0_2 来表示环上的服务器 0。类似地，s1_0、s1_1 和 s1_2 表示环上的服务器 1。使用虚拟节点，每个服务器负责多个分区。带有标签 s0 的分区（边）由服务器 0 管理。另一方面，带有标签 s1 的分区由服务器 1 管理。
![[attachments/1002ba20bedddb435d41f81f0244dc90_MD5.jpeg]]
要查找密钥存储在哪个服务器上，我们从密钥的位置开始顺时针方向查找环上遇到的第一个虚拟节点。在图 5-13 中，要查找 k0 存储在哪个服务器上，我们从 k0 的位置开始顺时针查找虚拟节点 s1_1，它指向服务器 1。



![[attachments/2cdb7e6030d960d31dd52d538e087326_MD5.jpeg]]


### 查找受影响的密钥 Find affected keys

添加或删除服务器时，需要重新分配一小部分数据。我们如何找到受影响的范围来重新分配密钥？

在图 5-14 中，服务器 4 被添加到环中。受影响的范围从 s4（新添加的节点）开始，并沿环逆时针移动，直到找到服务器（s3）。因此，位于 s3 和 s4 之间的密钥需要重新分配到 s4。
![[attachments/933b575a7478fa034af153d2b94e8d06_MD5.jpeg]]

如图 5-15 所示，当移除一个服务器（s1）时，受影响的范围从 s1（移除节点）开始，沿环逆时针移动，直到找到一个服务器（s0）。因此，位于 s0 和 s1 之间的密钥必须重新分发到 s2。

![[attachments/e2a55eb3bb95a684ba6d4fdb589e08db_MD5.jpeg]]


![[../../../后端/算法/图解什么是一致性哈希算法|图解什么是一致性哈希算法]]


![[../../../后端/算法/图解系列 - 一致性Hash算法(7K字 13 图讲解&附实现，看不懂你diss我)|图解系列 - 一致性Hash算法(7K字 13 图讲解&附实现，看不懂你diss我)]]
# 第六章：设计键值存储

## 知识点
- CAP 定理：了解一致性、可用性和分区容错性之间的权衡。
- 一致性哈希：使用一致性哈希来将数据分区到多个服务器上。
- 数据复制：将数据异步复制到多个服务器上，提高可用性和可靠性。
- 仲裁共识：使用仲裁共识来保证读写操作的一致性。 
- 一致性模型：了解不同的一致性模型（强一致性、最终一致性等）。
- 版本控制：使用向量时钟来检测和解决冲突。
- 故障检测：使用八卦协议来检测服务器故障。 
- 处理临时故障：使用松散仲裁和暗示移交来提高可用性。
- 处理数据中心故障：将数据复制到多个数据中心，以应对数据中心故障。

## 一致性
由于数据在多个节点上复制，因此必须在副本之间同步。仲裁共识可以保证读写操作的一致性。让我们首先建立几个定义。
N = 副本数
W = 大小为 W 的写入仲裁。要使写入操作被视为成功，必须从 W 个副本确认写入操作。
R = 大小为 R 的读取仲裁。要使读取操作被视为成功，读取操作必须等待至少 R 个副本的响应。考虑图 6-6 中所示的以下示例，其中 N = 3。
讨论了数据复制和一致性的重要性，解释了 N、W、R 的含义以及如何配置它们以满足不同的需求。

![[attachments/8aac371d5cc630c75dea854417e19416_MD5.jpeg]]

W = 1 并不意味着数据写入一台服务器。例如，对于图 6-6 中的配置，数据在 s0、s1 和 s2 上复制。W = 1 意味着协调器必须至少收到一个确认，写入操作才被视为成功。例如，如果我们从 s1 获得确认，则不再需要等待来自 s0 和 s2 的确认。协调器充当客户端和节点之间的代理。
W、R 和 N 的配置是延迟和一致性之间的典型权衡。如果 W = 1 或 R = 1，则操作会快速返回，因为协调器只需等待来自任何副本的响应。如果 W 或 R > 1，系统提供更好的一致性；但是，查询会更慢，因为协调器必须等待来自最慢副本的响应。
如果 W + R > N，则强一致性得到保证，因为必须至少有一个
重叠节点具有最新数据才能确保一致性。
如何配置 N、W 和 R 以适应我们的用例？以下是一些可能的设置：
如果 R = 1 且 W = N，则系统针对快速读取进行了优化。
如果 W = 1 且 R = N，则系统针对快速写入进行了优化。
如果 W + R > N，则强一致性得到保证（通常 N = 3，W = R = 2）。
如果 W + R <= N，则无法保证强一致性。
根据要求，我们可以调整 W、R、N 的值以达到所需的一致性级别。
### 一致性模型
一致性模型是设计键值存储时要考虑的另一个重要因素。一致性模型定义了数据一致性的程度，并且存在多种可能的一致性模型：
• 强一致性：任何读取操作都会返回与最新写入数据项的结果相对应的值。客户端永远不会看到过时的数据。
• 弱一致性：后续读取操作可能看不到最新的值。
• 最终一致性：这是弱一致性的一种特定形式。如果有足够的时间，所有更新都会传播，并且所有副本都是一致的。
强一致性通常是通过强制副本不接受新的读取/写入，直到每个副本都同意当前写入来实现的。这种方法并不适用于高可用性系统，因为它可能会阻止新操作。Dynamo 和 Cassandra 采用最终一致性，这是我们为键值存储推荐的一致性模型。从并发写入开始，最终一致性允许不一致的值进入系统并强制客户端读取值以进行协调。下一节将解释协调如何与版本控制配合使用。




# 第七章：设计分布式唯一 ID 生成器

可以使用多种选项在分布式系统中生成唯一 ID。我们考虑的选项包括：
## 多主复制 Multi-master replication
使用数据库的自动递增功能，并根据服务器数量增加 ID

![[attachments/65135cde1e41ab92461a90b0d8c62787_MD5.jpeg]]
这种方法使用数据库的 auto_increment 功能。我们不是将下一个 ID 增加 1，而是将其增加 k，其中 k 是正在使用的数据库服务器的数量。如图 7-2 所示，要生成的下一个 ID 等于同一服务器中的前一个 ID 加 2。这解决了一些可扩展性问题，因为 ID 可以随着数据库服务器的数量而扩展。但是，这种策略有一些主要缺点：
• 难以通过多个数据中心进行扩展
• ID 不会随着时间的推移在多个服务器上增加。
• 在添加或删除服务器时，它无法很好地扩展。

## 通用唯一标识符 (UUID)  Universally unique identifier (UUID)
使用 UUID 生成器独立生成 ID

## 票证服务器 Ticket server
使用集中式票据服务器生成 ID

## Twitter 雪花方法 Twitter snowflake approach
将 ID 分为多个部分，包括时间戳、数据中心 ID、机器 ID 和序列号
![[attachments/5a24115647c4c8d4c4d279c7eafbaefc_MD5.jpeg]]
![[../../../后端/算法/雪花算法把玩|雪花算法把玩]]


![[../../../后端/算法/图解雪花算法|图解雪花算法]]





# **第八章：设计 URL 缩短器**

- **技术要点：** 设计一个 URL 缩短服务，将长 URL 转换为短 URL，并支持重定向功能。
- **技术点：**
- 哈希函数：使用哈希函数将长 URL 映射到短 URL。 
- 哈希值长度：根据系统规模和字符集确定哈希值的长度。
- 哈希冲突解决：使用递归追加字符串或布隆过滤器来解决哈希冲突。
- Base 62 转换：将唯一 ID 转换为 Base 62 编码的短 URL。
- URL 缩短流程：生成唯一 ID，转换为短 URL，存储到数据库中。 
- URL 重定向流程：从缓存或数据库中查找长 URL，重定向到长 URL。
- 分布式唯一 ID 生成器：使用第七章中讨论的方法生成唯一 ID。

# **第九章：设计网络爬虫**

- **技术要点：** 设计一个网络爬虫，用于从互联网上收集数据。
- **技术点：**
- 种子 URL：爬虫的起始 URL。
- URL 边界：存储待下载 URL 的队列。
- HTML 下载器：从互联网上下载网页。
- DNS 解析器：将 URL 转换为 IP 地址。
- 内容解析器：从网页中提取数据。
- URL 过滤器：排除特定类型的内容、文件扩展名、错误链接和黑名单网站中的 URL。
- URL 已访问记录：记录已访问过的 URL，避免重复下载。
- 爬虫工作流程：下载网页、提取链接、过滤链接、检查是否已访问、添加到 URL 边界。
- 礼貌性：避免在短时间内向同一主机发送过多请求。
- URL 优先级：根据网页重要性或更新频率设置 URL 优先级。
- 新鲜度：定期重新抓取已下载的网页，保持数据新鲜度。
- 健壮性：处理异常，避免系统崩溃。
- 可扩展性：支持新的内容类型，可通过插件扩展功能。 

# **第十章：设计通知系统**

- **技术要点：** 设计一个通知系统，向用户发送各种类型的通知，例如推送通知、短信和电子邮件。
- **技术点：**
- 通知类型：推送通知、短信、电子邮件。
- 联系信息收集：收集用户的设备令牌、电话号码和电子邮件地址。
- 通知发送/接收流程：服务触发通知事件、通知服务发送通知、第三方服务发送通知。
- 可靠性：保证通知的可靠传递。 
- 通知模板：使用预先格式化的模板来创建通知。
- 通知设置：允许用户自定义通知设置。
- 限速：限制来自单个用户或服务的通知数量。 
- 重试机制：如果通知发送失败，则重试发送。 
- 推送通知的安全性：确保推送通知的安全性。
- 监控排队的通知：监控通知队列，确保及时发送通知。
- 事件跟踪：跟踪通知的打开率、点击率和参与度。

# **第十一章：设计新闻 Feed 系统**

- **技术要点：** 设计一个新闻 Feed 系统，为用户提供来自其关注的人或群组的最新帖子。
- **技术点：**
- Feed 发布流程：用户发布帖子、存储到数据库、推送到消息队列、添加到关注者的 Feed 缓存、发送通知。
- Feed 获取流程：用户请求 Feed、从缓存中获取帖子 ID 列表、从数据库中获取帖子数据、返回给客户端。 
- Fanout 服务：将新发布的帖子推送到关注者的 Feed 中。
- Fanout 模型：推模型、拉模型、混合模型。
- 缓存架构：Feed 缓存、内容缓存、社交图谱缓存、操作缓存、计数器缓存。


# **第十二章：设计聊天系统**

- **技术要点：** 设计一个聊天系统，支持一对一聊天和群组聊天，并提供在线状态指示器。
- **技术点：**
- 通信协议：HTTP、长轮询、WebSocket。
- 系统组件：聊天服务器、状态服务器、API 服务器、通知服务器、键值存储。 
- 数据存储：关系型数据库、NoSQL 数据库。
- 数据模型：消息表（一对一聊天、群组聊天）。
- 消息同步：跨多个设备同步消息。
- 在线状态：管理用户的在线/离线状态。
- 在线状态传播：使用发布-订阅模型将在线状态更新传播给朋友。

[从无到有：微信后台系统的演进之路_语言 & 开发_张文瑞_InfoQ精选文章](https://www.infoq.cn/article/the-road-of-the-growth-weixin-background)

# **第十三章：设计搜索自动完成系统**

- **技术要点：** 设计一个搜索自动完成系统，根据用户输入的前缀提供最相关的搜索建议。
- **技术点：**
- 数据收集服务：收集用户输入的查询并实时聚合它们。 
- 查询服务：根据搜索查询或前缀返回最常搜索的词条。
- Trie 数据结构：使用 Trie 来存储搜索查询及其频率。 
- 数据处理：使用分析日志、聚合器和键值存储来处理搜索查询数据。
- 缓存：使用缓存来存储 Trie 数据结构。
- 分片：将 Trie 数据结构分片到多个服务器上。 

[我们如何构建前缀：一个支持自动完成的可扩展前缀搜索服务|Prefixy团队|介质 --- How We Built Prefixy: A Scalable Prefix Search Service for Powering Autocomplete | by Prefixy Team | Medium](https://medium.com/@prefixyteam/how-we-built-prefixy-a-scalable-prefix-search-service-for-powering-autocomplete-c20f98e2eff1)
[Prefix Hash Tree An Indexing Data Structure over Distributed Hash Tables:](https://people.eecs.berkeley.edu/~sylvia/papers/pht.pdf)


# **第十四章：设计 YouTube**

- **技术要点：** 设计一个类似 YouTube 的视频分享平台，支持视频上传、处理、存储和流媒体播放。
- **技术点：**
- 内容分发网络（CDN）：用于存储和分发视频内容。 
- API 服务器：处理除视频流媒体播放之外的所有功能。
- 视频上传流程：客户端上传视频、服务器处理视频、存储到云存储、生成预签名上传 URL。 
- 视频处理：视频编码、缩略图生成、水印添加、元数据提取。
- 数据存储：云存储、块存储、元数据数据库、缓存。 
- 视频流媒体播放：使用流媒体协议（HLS、DASH）将视频内容传输到客户端。
- 优化：预取、缓存、自适应比特率流媒体播放。

# **第十五章：设计 Google 云端硬盘**

- **技术要点：** 设计一个类似 Google 云端硬盘的云存储服务，支持文件上传、下载、同步、版本控制和共享。
- **技术点：**
- 块服务器：将文件分割成块，压缩、加密并上传到云存储。
- 云存储：用于存储文件块。 
- 冷存储：用于存储不常访问的数据。 
- API 服务器：处理用户认证、文件元数据管理等功能。
- 元数据数据库：存储用户、文件、块和版本等元数据。
- 上传流程：客户端上传文件、块服务器处理文件、上传到云存储、更新元数据数据库。 
- 下载流程：客户端下载文件、从云存储下载块、组装文件。 
- 同步：使用增量同步来减少网络流量。 
- 一致性：保证元数据缓存和数据库层面的强一致性。
- 故障处理：处理负载均衡器、块服务器、云存储、API 服务器、元数据缓存和数据库的故障。 

# 分布式系统设计面试常见问题

## 1. 如何将一个系统从零扩展到百万用户？


## 2. 什么是一致性哈希，它在分布式系统中有什么作用？

一致性哈希是一种特殊的哈希算法，用于将数据均匀分布到多个服务器上，同时最小化数据迁移的成本。它的主要作用包括：

- **减少数据迁移：** 当添加或移除服务器时，只有一小部分数据需要迁移，而不是所有数据。
- **平衡负载：** 数据能够更均匀地分布在服务器上，避免热点问题，提高系统整体性能。

**工作原理：**

1. **哈希环：** 将哈希函数的输出范围映射到一个环形结构上。
2. **服务器映射：** 将服务器的标识（例如 IP 地址）哈希到哈希环上。
3. **数据映射：** 将数据的键哈希到哈希环上。
4. **查找服务器：** 顺时针查找数据键在哈希环上的位置，遇到的第一个服务器即为存储该数据的服务器。

**虚拟节点：**

为了更均匀地分布数据，每个服务器可以使用多个虚拟节点，每个虚拟节点代表服务器在哈希环上的一个位置。

**应用场景：**

- 分布式缓存系统（例如 Memcached）
- 分布式数据库系统（例如 Cassandra）
- 分布式负载均衡器



## 4. 如何设计一个唯一 ID 生成器？

在分布式系统中设计唯一 ID 生成器需要满足以下要求：

- **唯一性：** 生成的 ID 必须是唯一的。
- **有序性：** 生成的 ID 应该是有序的，以便于排序和查询。
- **可扩展性：** ID 生成器应该能够处理高并发请求。

**常见方案：**

- **多主数据库复制：** 使用数据库自增主键，但在分布式环境中需要处理数据同步和一致性问题。
- **UUID：** 生成全局唯一的 ID，但 ID 较长且无序。
- **Ticket 服务器：** 维护一个中心化的 Ticket 服务器，负责分配 ID 区间给不同的服务器，以生成唯一 ID。
- **雪花算法（Twitter Snowflake）：** 将 ID 分成多个部分，例如时间戳、数据中心 ID、机器 ID 和序列号，以生成唯一且有序的 ID。

## 5. 如何设计一个短链接服务？

短链接服务用于将长 URL 转换为短 URL，并提供重定向功能。设计要点包括：

- **哈希函数：** 使用哈希函数将长 URL 转换为短码。
- **存储：** 存储短码和长 URL 的映射关系，可以使用关系型数据库或键值存储。
- **重定向：** 处理短 URL 的重定向请求，将用户重定向到原始长 URL。
- **高可用性：** 确保服务的高可用性，例如使用负载均衡和冗余存储。

**哈希函数选择：**

- MD5 或 SHA-1： 生成较长的哈希值，需要截取一部分作为短码。
- 自定义哈希函数： 可以根据需求设计自定义的哈希函数，例如使用 base62 编码。

**解决哈希冲突：**

- 追加随机字符： 在短码后追加随机字符，直到生成唯一的短码。
- 存储多个映射关系： 存储短码和多个长 URL 的映射关系，根据请求参数或其他规则选择合适的长 URL 进行重定向。

## 6. 如何设计一个网络爬虫？

网络爬虫用于自动抓取互联网上的网页内容。设计要点包括：

- **URL 管理：** 维护待抓取 URL 列表，并记录已抓取 URL，避免重复抓取。
- **页面抓取：** 使用 HTTP 客户端下载网页内容。
- **内容解析：** 使用 HTML 解析器提取网页中的链接和其他有用信息。
- **数据存储：** 将抓取到的数据存储到数据库或文件系统中。
- **分布式架构：** 使用分布式架构提高抓取效率，例如使用多个爬虫节点和消息队列。

**其他考虑因素：**

- **robots.txt 协议：** 遵守 robots.txt 协议，避免抓取不允许抓取的网站。
- **抓取频率：** 控制抓取频率，避免对目标网站造成过大的压力。
- **去重：** 避免抓取重复内容，可以使用指纹算法或其他方法。
- **内容过滤：** 根据需求过滤抓取到的内容，例如过滤广告或无关信息。

## 7. 如何设计一个消息推送系统？

消息推送系统用于向用户推送消息通知。设计要点包括：

- **消息存储：** 存储待推送的消息，可以使用关系型数据库或消息队列。
- **推送服务：** 负责将消息推送到用户设备。
- **用户管理：** 管理用户信息，例如设备 ID、订阅主题等。
- **消息格式：** 定义消息格式，例如使用 JSON 或 XML。
- **推送通道：** 选择合适的推送通道，例如 Apple Push Notification Service (APNS) 或 Firebase Cloud Messaging (FCM)。

**可靠性保障：**

- **消息持久化：** 将消息持久化到磁盘，避免消息丢失。
- **重试机制：** 当推送失败时，进行重试。
- **确认机制：** 确保消息成功推送到用户设备。

**安全性：**

- **身份验证：** 对推送服务进行身份验证，防止未授权访问。
- **消息加密：** 对敏感信息进行加密，保护用户隐私。

## 8. 如何设计一个键值存储？

键值存储是一种非关系型数据库，使用键值对存储数据。设计要点包括：

- **数据结构：** 选择合适的数据结构存储键值对，例如哈希表、树或跳表。
- **数据分区：** 将数据分区到多个服务器上，提高可扩展性。
- **一致性模型：** 选择合适的一致性模型，例如最终一致性或强一致性。
- **容错机制：** 处理服务器故障和数据丢失。

**常见技术：**

- **一致性哈希：** 用于数据分区和负载均衡。
- **复制：** 将数据复制到多个服务器上，提高可用性。
- **Merkle 树：** 用于数据一致性校验。
- **LSM 树：** 用于高效地写入和读取数据。
